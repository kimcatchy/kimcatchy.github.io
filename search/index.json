[{"content":"증명의 이해 증명을 위해서 참(T)인 전제들이 주어져야 함\n이 전제들의 결론 역시 참(T)이 되어 유효추론이 성립되면 정확한 증명이라고 할 수 있음\n유효추론: 주어진 전제를 이용해 유도된 결론이 정확한 추론, 전제가 참일 때 결론이 모두 참인 추론\n공리 (Axiom) 별도의 증명 없이 항상 참으로 이용되는 명제\ne.g. 어떤 자연수 n에 대해, (n+1)이 존재한다.\n정의 (Definition) 논의의 대상을 보편화하기 위해 사용하는 용어 또는 기호의 의미를 확실하게 규정한 문장이나 식\nex) 명제는 객관적인 기준으로 진릿값을 판별할 수 있는 문장이나 수식이다.\n정리 (Theorem) 공리와 정의를 통해 참으로 확인된 명제\ne.g. 피타고라스의 정리, 이항정리, 나머지정리 등\n증명 (Proof) 하나의 명제가 참임을 확인하는 과정 직접증명법 명제의 변형 없이 공리·정의·정리를 이용하여 증명하는 방법\n조건명제 p→q가 참임을 증명하기 위해 전제 p를 참으로 가정했을 때 결론 q도 참임을 증명하는 방법\n직접증명법의 특징 논리적 연결: 공리, 정의, 그리고 이미 증명된 정리를 논리적으로 직접 연결하여 증명\n변형 없음: 명제를 다른 형태로 변형하지 않고 그대로 증명\n연역적 접근: 직접증명법은 연역(deduction)이라고도 불리며, 주어진 사실들과 공리들에 입각하여 추론을 통해 새로운 사실을 도출\n간접증명법 증명하고자 하는 명제의 결론을 직접 증명하는 대신, 그 명제의 부정이나 대우를 이용하여 간접적으로 증명하는 방법 대우증명법 조건명제 p → q와 그의 대우 ¬q → ¬p가 동치임을 이용하여 증명하는 방법 [object Promise] 1. 대우 명제: \u0026ldquo;x가 짝수도 아니고 홀수도 아니면, x²-x는 홀수이다.\u0026rdquo;\n1. 논리학에서 전제가 거짓인 조건문은 항상 참(공허참) 1. 대우 명제가 참이므로 원래의 명제도 참 모순증명법 (귀류법) 조건명제 p → q와 ¬(p∧¬q)가 동치임을 이용하여 p∧¬q가 거짓임을 보여 증명하는 방법\n아래의 두 예시는 귀류법으로만 증명이 가능\n[object Promise] 1. 가정: √2 = a/b (a, b는 정수, b ≠ 0, a/b는 하한항)\n1. 양변에 제곱: `[2 = a²/b²] \u0026gt; [2b² = a²]` 1. `2b²`은 짝수이므로 `a²`도 짝수이고 `a`도 짝수 1. `[a = 2k] \u0026gt; [4k² = a² = 2b²] \u0026gt; [b² = 2k²]` 이므로 `b`는 짝수 1. `a`와 `b`가 모두 짝수이므로 `a/b`는 하한항이 아니게 됨 1. 따라서 √2가 하한항인 유리수라는 것은 거짓 1. `a/b`가 하한항인 유리수라는 가정이 모순되므로 √2는 무리수 [object Promise] 1. p: √5는 무리수이다.\n1. `¬q`: √3+√5는 무리수가 아니다. (유리수) 1. `p∧¬q`: √5는 무리수이고 √3+√5는 유리수이다. 1. 가정: `√3+√5 = a` (a ∈ 유리수, a ≠ 0) 1. `[√3 = a - √5] \u0026gt; [3 = a² - 2a√5 + 5] \u0026gt; [(a²+2)/2a = √5]` 1. a는 유리수라고 가정했으므로 `[(a²+2)/2a = √5]`의 좌변은 유리수이지만 우변이 √5이므로 가정이 성립하지 않음 1. 따라서 `p∧¬q`인 \u0026quot;√5는 무리수이고 √3+√5는 유리수이다.\u0026quot;가 거짓이므로 `p → q`는 참 존재증명법 주어진 명제가 참이 되는 예를 찾아서 증명하는 방법\n∃xP(x)\n반례증명법 주어진 명제에 모순이 되는 예를 찾아서 증명하는 방법\n∃x¬P(x)\n수학적 귀납법 0과 자연수에 대해 일정한 규칙을 나타내는 명제 P(n)이 성립하는 것을 증명하는 방법 구분 특징 기본가정 명제의 논의영역의 첫 번째 값 a에 대해 P(a)가 참임을 보인다. 귀납가정 논의영역에 속하는 임의의 값 k에 대해 P(k)가 참이라고 가정한다. 귀납증명 기본가정과 귀납가정을 이용해 (k+1)에 대해 P(k+1)이 참인지 증명한다. ","date":"2025-09-21T16:21:00+09:00","permalink":"https://kimcatchy.github.io/p/proof/","title":"Proof"},{"content":"플립플롭 1비트의 정보를 기억할 수 있는 회로로 컴퓨터의 캐시 메모리·레지스터를 구성하는 기본 회로\n전원이 있을 때만 기억이 유지되며, 전원이 차단되면 정보는 사라지는 휘발성 기억 소자\n래치(Latch) 수동적 또는 전자적 조작으로 상태를 바꾸지 않는 한 그 상태를 유지해 주는 장치 또는 회로\n주어진 상태를 보관 유지할 수 있도록 NAND 게이트 또는 NOR 게이트를 이용하여 회로를 구성\n논리 회로로 구성되었기 때문에 논리회로에 준하는 빠른 동작속도를 얻을 수 있고 플립플롭으로 활용\n기본적인 플립플롭 플립플롭과 래치는 두 개의 안정된 상태 중 하나를 가지는 1비트 기억 소자\n플립플롭과 래치도 게이트로 구성되지만 조합논리회로와 달리 궤환(feedback)이 있음\n래치회로는 근본적으로는 플립플롭과 유사한 기능을 수행\nNOR 게이트로 구성된 S-R 래치 S R Q Q\u0026rsquo; 0 0 불변 불변 0 1 0 1 1 0 1 0 1 1 불능 불능 D 플립플롭 CP D Q Q\u0026rsquo; 1 0 0 1 1 1 1 0 입력 단자 R과 S에 동시에 1이 입력되어 불능이 되는 것을 회로적으로 차단\n입력신호 D가 클럭펄스(CP)에 의해 변화 없이 그대로 출력에 전달되는 특성을 가지고 있어, 데이터(Data)를 전달하는 것과 지연(Delay)을 의미하는 D 플립플롭이라고 함\nJ-K 플립플롭 R-S 플립플롭에서 R과 S에 동시에 1이 입력되어 불능 상태가 되는 것을 해결한 논리회로\nJ는 S에, K는 R에 대응하는 입력으로 J와 K의 입력이 동시에 1이 입력되면 플립플롭의 출력은 이전 출력의 보수 상태로 변화\nT 플립플롭 J-K 플립플롭의 J와 K 입력을 묶어서 하나의 입력 신호 T로 동작시키는 플립플롭\n입력이 0이 되면 이전 상태의 값이 그대로 출력되고, 입력이 1이 되면 이전 상태의 보수 값이 출력되게 되는 플립플롭\n","date":"2025-09-21T16:12:00+09:00","permalink":"https://kimcatchy.github.io/p/flip-flop/","title":"Flip-Flop"},{"content":"카르노 도표 조직적인 도표를 사용하여 부울 대수를 최적으로 간략화할 수 있음\n부울 대수식을 간소화하기 위한 가장 체계적이고 간단한 방법\n변수 1~5개로 이루어진 입력변수에 적용할 수 있으나 보통 4개까지만 적용\n변수가 2개인 카르노 도표 A\u0026rsquo;B\u0026rsquo;, A\u0026rsquo;B, AB\u0026rsquo;, AB A B X 최소항 기호 0 0 1 A\u0026rsquo;B' m₀ 0 1 0 A\u0026rsquo;B m₁ 1 0 0 AB' m₂ 1 1 1 AB m₃ 변수가 2개인 카르노 도표의 표현 A / B 0 1 0 A\u0026rsquo;B' A\u0026rsquo;B 1 AB' AB 출력이 0인 경우 빈칸으로 표시하고 1인 경우에만 표시 A / B 0 1 0 1 1 1 변수가 4개인 카르노 도표 AB / CD 00 01 11 10 00 1 1 01 1 11 1 1 10 카르노 도표에서 행과 열의 이웃관계 이웃과의 그룹화로 부울 대수를 간략화할 수 있게 함\n카르노 도표는 평면 형태로 보이나 실제로는 원통 형태나 구 형태\n부울 대수식의 간략화 주어진 부울식이나 진리표에 근거하여 카르노 도표를 작성\n그룹화를 수행\n그룹화 = 공통변수를 묶는 개념\n카르노 도표에서 1로 표시된 이웃들을 1, 2, 4, 8, 16개씩 그룹화\n가능하면 큰 개수로 그룹화하는 것이 간략화의 효과가 큼\n각각 다른 그룹에 여러 번 중복하여 그룹화할 수 있음\n그룹화할 이웃이 없는 경우 단독으로 그룹화되고 이것은 간략화되지는 않음\n각 그룹을 간략화\n간략화된 부울 대수식끼리 OR 연산\n무관 조건 출력에 관여하지 않는 입력 변수를 무관 조건이라고 함\n카르노 도표에서 x로 표기\n이웃 영역을 그룹화할 때 가장 간단한 표현을 얻기 위해 임의로 채워질 수 있음\n간략화 과정에서 그룹화할 수도 있고 그룹화하지 않을 수도 있음\n어떤 입력 변수 조합이 허용되지 않는 상황이 발생했을 때 사용\n논리 회로의 설계 방법 문제로부터 논리적 정의를 명확히 내림\n문제로부터 논리 진리표를 작성\n진리표로부터 카르노 도표 작성\n카르노 도표로부터 논리식을 간략화\n논리회로를 그림\n","date":"2025-09-21T16:10:00+09:00","permalink":"https://kimcatchy.github.io/p/boolean-expression-simplification/","title":"논리식의 간소화"},{"content":"논리 회로 2진수의 논리연산을 수행하는 회로\n논리게이트의 동작은 수학적으로 부울 대수로 표현 가능\n게이트의 입력과 출력 관계는 진리표로 나타냄\nAND: 모든 입력이 1인 경우에만 1을 출력하고 나머지의 경우에는 0을 출력\n마스크 연산 OR: 입력 중 하나라도 1이라면 1을 출력하고 모두 0이라면 0을 출력\n선택적-세트 연산 NOT: 입력값에 대해 출력값이 반대가 되도록 함\nXOR: 여러 개의 입력 중에서 1의 개수가 홀수로 입력되면 1을 출력\n선택적-보수 연산\n비교 연산\nNAND: AND + NOT, AND의 출력과 반대로 출력, 모든 입력이 1인 경우에만 0을 출력하고 나머지는 1을 출력\nNegative-OR NOR: OR + NOT, 여러 개의 입력 중 최소한 하나 이상의 입력이 1을 갖는 경우 0을 출력\nNegative-AND XNOR: XOR + NOT, 여러 개의 입력 중에서 1의 개수가 홀수로 입력되면 0을 출력\n범용 논리 게이트 NAND와 NOR 게이트로 디지털 시스템에서 사용되는 모든 논리 게이트를 구성할 수 있음\n유니버셜 게이트 또는 범용 게이트라고 함\n불 대수 인간의 사고과정을 수학적으로 해석한 것\n임의의 명제가 참인지를 판명하기 때문에 논리 대수라고도 함\n변수들의 진리표 관계를 대수식으로 표현하기 용이\n동일한 성능을 갖는 더 간단한 회로 만들기에 편리 불 대수의 기본 법칙 교환법칙\n입력들의 순서가 변경되더라도 논리 연산의 결과는 동일하게 출력\nA·B = B·A\nA+B = B+A\n결합법칙\n세 입력이 동일한 논리 연산을 수행할 때, 입력의 순서가 바뀌어 연산이 수행되어도 결과는 동일함\nA·(B·C) = (A·B)·C\nA+(B+C) = (A+B)+C\n분배법칙\nA·(B+C) = A·B + A·C 다중 부정\n논리 부정이 여러 번 수행되는 것 드모르간의 법칙\n여러 논리 변수의 논리합 전체를 부정(NOR)하면 그것은 원래의 논리 변수를 각각 부정한 것을 논리곱한 것과 같음\n여러 논리 변수의 논리곱 전체를 부정(NAND)하면 그것은 원래의 논리 변수를 각각 부정한 것을 논리합한 것과 같음\n불 대수의 기본 정리 +는 합집합, ·는 교집합, NOT은 여집합이라고 생각하면 됨\nA+0 = A\nA+1 = 1\nA·0 = 0\nA·1 = A\nA+A = A\nA+Ā = 1\nA·A = A\nA·Ā = 0\nA\u0026rsquo;\u0026rsquo; = A (A 위에 바 2개..)\nA+AB = A\nA+ĀB = A+B\n(A+B)·(A+C) = A+BC\n불 대수의 표준형 최소항\n변수들이 AND로 결합된 것\n변수 값이 참(1)인 경우는 정상형태인 A, B, C의 형태를 사용\n변수 값이 거짓(0)인 경우는 보수형태인 Ā, B̄, C̄의 형태를 사용\n표준 곱의 항이라고 함\n최대항\n변수들이 OR로 결합된 것\n변수 값이 참(1)인 경우는 보수형태인 Ā, B̄, C̄의 형태를 사용\n변수 값이 거짓(0)인 경우는 정상형태인 A, B, C의 형태를 사용\n표준 합의 항이라고 함\n표준 곱의 항과 표준 합의 항에서 표준의 의미는 불 대수가 모든 변수를 포함하고 있다는 것을 뜻함\n곱의 합 (Sum of Products, SOP)\n각 항이 변수들의 곱(AND)으로 이루어져 있고, 이 항들이 합(OR)으로 연결\n(A + B)(C + D) 형태\n최소항의 합으로 표현되며, 시그마(Σ) 기호로 나타냄\n합의 곱 (Product of Sums, POS)\n각 항이 변수들의 합(OR)으로 이루어져 있고, 이 항들이 곱(AND)으로 연결\nAB + CD 형태\n최대항의 곱으로 표현되며, 파이(π) 기호로 나타냄\n","date":"2025-09-21T16:03:00+09:00","permalink":"https://kimcatchy.github.io/p/logic-gate/","title":"Logic Gate"},{"content":"명제 명제: 객관적인 기준으로 참/거짓을 구분할 수 있는 문장이나 수식\n논증: 전제와 결론으로 이루어져 어떤 주장이 옳다는 것을 보이기 위한 명제들의 나열\n결론: 논증의 마지막\n전제: 그 앞의 명제들\n진릿값: 참이나 거짓을 가리키는 값\n합성명제: 하나 이상의 명제가 결합되는 것, 부정·논리곱·논리합·배타적 논리합과 같은 논리연산자를 이용\n논리연산자 부정(NOT): ~p 또는 ¬p\n논리곱(AND): p∧q, 두 명제가 모두 참(1)일 때만 참\n논리합(OR): p∨q, 두 명제 중 하나라도 참이라면 참\n배타적 논리합(XOR): p⊻q 또는 p⊕q, 두 명제 중 하나만 참일 때만 참\n합성명제 우선순위: ① (), ② ¬, ③ ∧, ④ ∨\n항진명제: 합성명제를 구성하는 단일명제들의 진리값에 관계없이 항상 참인 합성명제\n모순명제: 합성명제를 구성하는 단일명제들의 진리값에 관계없이 항상 거짓인 합성명제\n사건명제: 항진명제도 모순명제도 아닌 합성명제\n조건명제 문장 p, q가 명제일 때, p가 가정 또는 전제이고, q가 결론 또는 결과가 되는 명제 (p → q)\np가 참이고 q가 거짓일 때만 거짓 = ~p∨q와 논리적 동치\n쌍방조건명제 p ↔ q = (p → q) ∧ (q → p)\n문장 p, q가 명제일 때, p와 q가 가정이면서 동시에 결론인 명제\np, q가 모두 참이거나 거짓일 때만 참\n역, 이, 대우 p q 조건명제 역 이 대우 p → q q → p ~p → ~q ~q → ~p T T T T T T T F F T T F F T T F F T F F T T T T 원 명제가 참이면 그 대우 명제도 반드시 참이다. 논리적 동치 P = Q\n두 개의 합성명제 P와 Q의 진릿값이 서로 같은 경우\n논리적 등치 법칙 p∧T ≡ p p∨F ≡ p 항등법칙 p∧F ≡ F p∨T ≡ T 지배법칙 p∧¬p ≡ F p∨¬p ≡ T 부정법칙 ¬(¬p) ≡ p 이중부정법칙 p∧p ≡ p p∨p ≡ p 멱등법칙 p∧q ≡ q∧p p∨q ≡ q∨p 교환법칙 (p∧q)∧r ≡ p∧(q∧r) (p∨q)∨r ≡ p∨(q∨r) 결합법칙 p∨(q∧r) ≡ (p∨q)∧(q∨r) p∧(q∨r) ≡ (p∧q)∨(q∧r) 분배법칙 ¬(p∧q) ≡ ¬p∨¬q ¬(p∨q) ≡ ¬p∧¬q 드모르간의 법칙 p∧(p∨q) ≡ p p∨(p∧q) ≡ p 흡수법칙 p → q ≡ ¬p∨q 함축법칙 명제함수 P(x)\n논의영역이 주어진 변수 x를 포함하여 진릿값을 판별할 수 있는 문장이나 수식\n논의영역(D): 명제함수에 포함된 변수 x의 범위나 값\n전체한정자(전칭한정자) ∀ 논의영역의 모든 값\n논의영역 D에 속하는 모든 x에 대한 명제, P(x) : ∀xP(x)\n전체한정자로 범위가 정해진 명제함수는 논의영역에 포함되는 모든 원소에 대해 그 명제가 참이면 명제 함수도 참\n논의영역에 포함되는 원소 중 하나라도 명제가 거짓이면 그 명제함수는 거짓\n[object Promise]### 존재한정자 ∃\n논의영역 중 어떤 값\n논의영역 D에 속하는 원소 중 어떤 x에 대한 명제, P(x) : ∃xP(x)\n[object Promise]### 한정자와 부정연산자\n명제함수도 명제이기 때문에 논리연산이 가능\n한정자와 AND, OR에 대한 정리\n∀x(P(x)∧Q(x)) ≡ ∀xP(x)∧∀xQ(x)\n∃x(P(x)∨Q(x)) ≡ ∃xP(x)∨∃xQ(x)\n한정자와 NOT에 대한 정리\n¬(∀x(P(x)) ≡ ∃x(¬P(x))\n¬(∃x(P(x)) ≡ ∀x(¬P(x))\n추론(논증) 참인 명제를 근거로 하여 다른 명제가 참임을 유도하는 방식\n전제(가정): 결론의 근거가 되는 최종 결론을 제외한 명제, 진릿값이 참으로 간주되는 명제\n결론: 주어진 전제에 의해 유도된 명제\n유효추론: 주어진 전제를 이용해 유도된 결론이 정확한 추론 = 전제가 참일 때 결론이 모두 참인 추론\n허위추론: 주어진 전제를 이용해 유도된 결론이 틀린 추론 = 전제가 참인 경우 결론이 거짓인 경우가 하나라도 있는 추론\n","date":"2025-09-21T15:58:00+09:00","permalink":"https://kimcatchy.github.io/p/proposition-and-argument/","title":"Proposition \u0026 Argument"},{"content":"복소수 수학에서 실수와 허수의 합으로 표현되는 수\n일반적인 형태는 a + bi, a는 실수부, b는 허수부, i는 허수 단위로 정의되어 i² = -1을 만족\n기초 개념 실수부와 허수부: 복소수 z = a + bi에서 a는 실수부, b는 허수부\n실수부는 복소평면의 x축에 해당\n허수부는 y축에 해당\n복소평면: 복소수는 복소평면(또는 아르간 평면)에서 점으로 나타낼 수 있음\n이 평면에서 실수 축은 x축, 허수 축은 y축으로 구성 복소수의 연산 덧셈과 뺄셈: 두 복소수를 더하거나 빼려면 각각의 실수부끼리, 허수부끼리 연산\ne.g. (a + bi) + (c + di) = (a + c) + (b + d)i\ne.g. (a + bi) - (c + di) = (a - c) + (b - d)i\n곱셈: 두 복소수를 곱할 때는 분배법칙을 사용하며, i² = -1 임을 고려\ne.g. (a + bi)(c + di) = (ac - bd) + (ad + bc)i 나눗셈: 나눗셈은 분모의 켤레복소수를 이용하여 계산\ne.g. (a + bi) / (c + di) × {c - di) / (c - di) = {(ac + bd) + (bc - ad)i} / (c² + d²) 복소수의 기하학적 해석 절댓값: 복소수 z = a + bi의 절댓값(크기)은 원점에서 해당 점까지의 거리\n|z| = √(a² + b²) 로 정의 편각: 복소평면에서 실수축과 이루는 각도(편각)는 θ = tan^(-1)(b/a) 로 구할 수 있음\n오일러 공식과 극형태 오일러 공식: 복소수를 지수 함수와 삼각 함수로 연결하는 중요한 공식\neⁱˣ = cos(x) + i·sin(x)\n이를 통해 복소수를 지수 형태로 표현할 수 있음\n극형태: 복소수를 극형태로 표현하면 z = r(cosθ + i·sinθ)\nr은 절댓값, θ는 편각\n극형태를 사용하면 곱셈과 나눗셈이 더욱 간단해짐\n","date":"2025-09-21T15:48:00+09:00","permalink":"https://kimcatchy.github.io/p/complex/","title":"Complex"},{"content":"보수의 정의 상호 보완하는 수로, 임의의 수를 보완해주는 다른 임의의 수\n컴퓨터에서 보수는 음수를 표현하는 데 사용\nr진법에서 정의되는 보수 → (r-1)의 보수, r의 보수\n(r-1)의 보수: (r^n - 1) - N, A라는 수에 B라는 수를 더한 결과값의 각 자리가 (r-1)이 될 때, B를 A에 대한 (r-1)의 보수라고 정의\nr의 보수: r^n - N, A라는 수에 B라는 수를 더해서 각 자리마다 자리올림이 발생하고 해당 자리는 0이 될 때, B를 A에 대한 r의 보수라고 정의\n부호가 없는 10진수의 뺄셈 연산에서 보수의 활용\n컴퓨터에서 뺄셈 연산은 보수를 이용하는 것이 효율적임\n부호를 표시하지 않는 10진수에서 보수를 이용한 뺄셈 연산으로, 임의의 수를 보완해주는 다른 임의의 수\n컴퓨터에서 보수는 음수를 표현하는 데 사용\nr진법에서 정의되는 보수 → (r-1)의 보수, r의 보수\n(r-1)의 보수: (r^n - 1) - N, A라는 수에 B라는 수를 더한 결과값의 각 자리가 (r-1)이 될 때, B를 A에 대한 (r-1)의 보수라고 정의\nr의 보수: r^n - N, A라는 수에 B라는 수를 더해서 각 자리마다 자리올림이 발생하고 해당 자리는 0이 될 때, B를 A에 대한 r의 보수라고 정의\n데이터의 2진수 표현 부호가 있는 2진 정수의 표현 ① 부호화 - 크기 표현: n비트로 구성된 2진수에서, 최상위 비트는 부호비트(signed bit)이고 나머지 n-1개의 비트들은 수의 절대 크기(magnitude)를 나타냄\n② 1의 보수 표현: 모든 비트를 반전 (0→1, 1→0)\n③ 2의 보수 표현: 모든 비트들을 반전하고, 결과값에 1을 더함\n보수를 이용하면 부호 비트가 자연스럽게 변경되고, 그 크기도 적절한 형태로 변경\n2의 보수는 0에 대한 표현이 하나만 있으며 산술 연산이 용이\n2의 보수는 가장 효율적이기 때문에 컴퓨터를 비롯한 디지털 장치에 부호를 갖는 2진수를 표현하는데 사용\n2진수의 표현 범위 -2ⁿ⁻¹ ≤ N ≤ -2ⁿ⁻¹ -1\nn비트 데이터의 경우로 일반화 했을 때의 수의 범위\n비트 확장 부호가 존재하는 데이터의 비트 수를 늘리는 연산을 비트확장이라고 함\n부호화 - 크기 표현의 비트 확장\n부호 비트를 확장되는 최상위 자리로 이동시키고, 나머지 새로 확장되는 크기 비트들은 0으로 채움 2의 보수로 표현된 2진수의 비트 확장(부호 비트 확장)\n확장되는 상위 비트들을 부호 비트와 동일한 값으로 채움 소수의 표현 소수를 포함하는 10진수의 2진수 표현\n① 정수 부분과 소수 부분을 분리\n② 정수 부분의 10진수를 2진수로 변환\n③ 소수 부분의 10진수를 2진수로 변환(2로 연속적인 곱셈을 수행하면서 생기는 자리 올림수)\n④ 얻어진 정수와 소수의 2진수를 합함\n소수점을 포함하고 있는 2진수를 10진수로 변환\n정수 부분은 2의 지수 승, 소수 부분은 2의 (-)지수 승을 사용 부동소수점의 표현 Floating-point\n고정소수점 표현\n소수가 고정된 소수점을 통해서 구분하여 표현된 방식\n표현 범위의 한계가 있어 아주 큰 값과 매우 작은 값을 표현하는 것이 불가능\n부동소수점 표현\n지수를 사용, 소수점의 위치를 이동하여 수의 표현 범위를 확대\n±M × B^±E\nM: 가수 / B: 기수 / E: 지수\n2진 부동소수점 수 표현\n단일-정밀도 부동소수점 수: 32비트로 표현\n부호 필드는 1비트로 0이면 양수이고 1이면 음수\n지수 필드(8비트)는 지수 값을 저장하는 곳\n가수 필드는 23비트로 표현, 고정소수점 수와 비교해서 표현할 수 있는 수의 넓이가 훨씬 넓음\n복수-정밀도 부동소수점 수: 64비트로 표현\n각 필드의 비트 할당 문제는 표현하는 수의 범위와 정밀도를 결정\n지수 필드의 비트 수가 늘어나면 표현 가능한 수의 범위가 확장\n가수 필드의 비트가 늘어나면 2진수로 표현할 수 있는 수가 많아져 정밀도가 증가\n바이어스된 지수값 정규화된 표현에서 소수점 우측의 첫 번째 비트는 항상 1로 생략 가능\n가수 필드 23비트를 이용하여 생략된 소수점 아래 첫 번째 1을 포함하여 24자리의 수까지 표현 가능하게 되어 1비트를 더 표현 가능 지수의 바이어스된 수(biased number)로 표현\n지수 필드의 지수는 양의 값뿐만 아니라 음의 값을 가지므로 부호에 대한 표현이 필요함\n지수를 바이어스된 수로 표현하면, 음수의 표현뿐만 아니라 0에 대한 표현에서 모든 비트가 0이 되게 함\nIEEE 754 표준 국제 표준: ±1.bbbb\u0026hellip;bbb × 2^±E\n단일 정밀도 형식\n지수: 8비트\n바이어스: 127\n가수: 23비트\n표현 영역: 10⁻³⁸ ~ 10³⁸\n복수 정밀도 형식\n지수: 11비트\n바이어스: 1023\n가수: 52비트\n표현 영역: 10⁻³⁰⁸ ~ 10³⁰⁸\n지수(E) 필드의 비트 수가 늘어나면 표현 가능한 수의 범위가 확장\n가수(M) 필드의 비트 수가 늘어나면 정밀도 증가\n2진수의 연산 산술 연산 덧셈은 특별한 게 없음\n뺄셈의 경우 빼는 수의 2의 보수를 구하고 뺄 수와 더하여 연산\n곱셈과 나눗셈도 10진수와 다를 게 없음\n논리 연산 주어진 명제에 대하여 참과 거짓을 결정하는 연산\n컴퓨터와 같은 디지털 장치에서는 많은 산술 연산 뿐만 아니라 다양한 논리 연산을 지원\nAND: 모든 입력이 1일 때 1을 출력하고 아닌 경우 0 출력\nOR: 입력 중 하나라도 1이면 1을 출력하고 아닌 경우 0 출력\nXOR: 입력이 모두 동일할 경우 0을 출력하고 아닌 경우 1 출력\nNOT: 입력의 반대를 출력\n응용 논리 연산 선택적 세트 연산: 2진수의 특정 비트를 선택하여서 1로 세트시키는 연산, 세트할 비트들에 OR 연산으로 세트\n선택적 보수 연산: 특정 부분만 비트를 반전, 반전할 비트들에 XOR 연산으로 반전\n마스크 연산: 원하는 비트들을 선택적으로 clear(0)하는데 사용하는 연산, clear할 부분에 AND 연산으로 clear\n삽입 연산: 특정 위치에 새로운 비트 값들을 삽입, 마스크 연산으로 clear 후 새로 삽입할 비트들로 OR 연산 수행\n비교 연산: 두 데이터를 비교하는 연산, XOR 연산을 통해 비교\n순환 이동: 최상위 또는 최하위에 있는 비트가 반대편 끝에 있는 비트 위치로 이동해서 비트가 회전\n순환 좌측 이동: 최상위 비트가 최하위 비트 위치로 이동\n순환 우측 이동: 촤하위 비트가 최상위 비트 위치로 이동\n산술적 이동: 이동 과정에서 부호 비트는 유지하고 수의 크기를 나타내는 비트들만 이동\n문자 데이터의 표현 패리티 비트: 전송 과정에서 1비트 오류를 검출하기 위한 비트\n표준 BCD 코드\n이진화 십진 코드\n기본적으로 6비트의 길이를 갖는 코드이지만 좀 더 효율적으로 사용하기 위해서 존 비트와 숫자 비트로 분리하고 이를 조합해서 코드를 생성\n패리티 비트(1) + 존 비트(2) + 숫자 비트(4) → 64가지의 문자, 숫자, 특수문자의 정보를 표현\n아스키 코드\n미국 국립 표준 연구소(ANSI)가 제정한 정보 교환용 미국 표준 코드\n코드의 길이는 7비트와 패리티 비트가 추가된 두 종류의 8비트 코드가 있으며 128(=2⁷)가지의 정보를 표현 가능\n패리티 비트(1) + 존 비트(3) + 숫자 비트(4)\n","date":"2025-09-20T01:37:00+09:00","permalink":"https://kimcatchy.github.io/p/complement/","title":"Complement"},{"content":"설치 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Fetch latest updates sudo apt -qqy update # Install all updates automatically sudo DEBIAN_FRONTEND=noninteractive apt-get -qqy -o Dpkg::Options::=\u0026#39;--force-confdef\u0026#39; -o Dpkg::Options::=\u0026#39;--force-confold\u0026#39; dist-upgrade # Install dependencies to install Docker sudo apt -qqy -o Dpkg::Options::=\u0026#39;--force-confdef\u0026#39; -o Dpkg::Options::=\u0026#39;--force-confold\u0026#39; install ca-certificates curl gnupg lsb-release # Register Docker package registry sudo mkdir -p /etc/apt/keyrings curl -fsSL \u0026lt;https://download.docker.com/linux/ubuntu/gpg\u0026gt; | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \u0026lt;https://download.docker.com/linux/ubuntu\u0026gt; $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # Refresh package udpates and install Docker sudo apt -qqy update sudo apt -qqy -o Dpkg::Options::=\u0026#39;--force-confdef\u0026#39; -o Dpkg::Options::=\u0026#39;--force-confold\u0026#39; install docker-ce docker-ce-cli containerd.io docker-compose-plugin # Create installation directory for Wiki.js sudo mkdir -p /etc/wiki # 이건 내가 쓰려고 추가, 이거 안 할 거면 아래 openssl도 sudo 써야 될? 듯? sudo chown ubuntu:ubuntu /etc/wiki # Generate DB secret openssl rand -base64 32 \u0026gt; /etc/wiki/.db-secret # Create internal docker network sudo docker network create wikinet # Create data volume for PostgreSQL sudo docker volume create pgdata # Create the containers sudo docker create --name=db -e POSTGRES_DB=wiki -e POSTGRES_USER=wiki -e POSTGRES_PASSWORD_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -v pgdata:/var/lib/postgresql/data --restart=unless-stopped -h db --network=wikinet postgres:17 sudo docker create --name=wiki -e DB_TYPE=postgres -e DB_HOST=db -e DB_PORT=5432 -e DB_PASS_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -e DB_USER=wiki -e DB_NAME=wiki -e UPGRADE_COMPANION=1 --restart=unless-stopped -h wiki --network=wikinet -p 80:3000 -p 443:3443 ghcr.io/requarks/wiki:2 sudo docker create --name=wiki-update-companion -v /var/run/docker.sock:/var/run/docker.sock:ro --restart=unless-stopped -h wiki-update-companion --network=wikinet ghcr.io/requarks/wiki-update-companion:latest 포트 변경 시 docker create --name=wiki 부분에서 80:3000과 443:3443에서 80, 443 변경 후 nginx로 돌려주면 됨\n5432, 3000, 3443은 서버 내에서만 사용돼서 따로 설정할 필요 없음\n오라클 클라우드 기준이면 상관 없는데 방화벽 설정 필요할 경우 ↓\nbash 1 2 3 4 5 sudo ufw allow ssh sudo ufw allow http sudo ufw allow https sudo ufw --force enable 실행 bash 1 2 3 sudo docker start db sudo docker start wiki sudo docker start wiki-update-companion 실행 후 Let\u0026rsquo;s Encrypt 인증 전 사이트 설정을 먼저 할 것\n사이트 설정 시 문서 생성하기 전에 언어 설정부터 변경\nLet\u0026rsquo;s Encrypt bash 1 2 3 4 5 6 7 sudo docker stop wiki sudo docker rm wiki sudo docker create --name=wiki -e LETSENCRYPT_DOMAIN=wiki.example.com -e LETSENCRYPT_EMAIL=admin@example.com -e SSL_ACTIVE=1 -e DB_TYPE=postgres -e DB_HOST=db -e DB_PORT=5432 -e DB_PASS_FILE=/etc/wiki/.db-secret -v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro -e DB_USER=wiki -e DB_NAME=wiki -e UPGRADE_COMPANION=1 --restart=unless-stopped -h wiki --network=wikinet -p 80:3000 -p 443:3443 ghcr.io/requarks/wiki:2 sudo docker start wiki sudo docker logs wiki restart 할 때마다 자동 갱신\nsudo docker restart wiki Discord Auth Discord Developer Portal \u0026gt; 어플리케이션 생성 \u0026gt; OAuth2\nClient ID, Client Secret 복사 wiki.js 관리 페이지 \u0026gt; 계정 인증 \u0026gt; 전략 추가 \u0026gt; 디스코드 선택\n복사한 Client ID, Client Secret 붙여넣기\n(선택) Server ID에 디스코드 서버의 ID를 입력하면 해당 서버의 멤버만 가입 가능\n서버 ID 입력 시 redirect가 정상적으로 되지 않을 경우 wiki.js restart 아래 쪽의 콜백 혹은 리다이렉트 URL 복사해서 Discord Developer Portal OAuth 페이지의 Redirects에 추가\n위 내용 모두 완료 후에 적용, 정상적으로 진행되는지 확인 후 관리 페이지 \u0026gt; 보안 \u0026gt; 로컬 인증 공급자 숨기기 활성화\n로그인 화면에서 디스코드만 뜨지만 url 뒤에 ?all이 있을 경우 로컬 로그인도 가능 로그인 페이지 배경 이미지 변경 관리 페이지 \u0026gt; 보안 \u0026gt; 로그인 \u0026gt; 로그인 배경 이미지 URL\nImgBB 같은 곳에 올리고 원본 이미지 링크 사용\n사용 후기 node.js 기반이라 써봤는데 그냥 노션에 쓰고 말지 딱히 메리트가 있는 것 같지는 않다..\n","date":"2025-09-19T23:54:00+09:00","permalink":"https://kimcatchy.github.io/p/wiki-js-2/","title":"Wiki.js v2.0"},{"content":"Cloudflare DNS 설정 Cloudflare 대시보드의 DNS 탭에서 주소에 대해 A 레코드를 추가하고 서버 IP를 가리키도록 설정\n네임서버가 Cloudflare로 이미 설정돼 있지 않다면, Cloudflare Registrar에서 Cloudflare 네임서버로 변경 후 5~10분 정도 기다리면 됨\nOrigin Pulls 활성화 SSL/TLS \u0026gt; 개요(Overview) 탭에서 암호화 모드를 Full (strict) 로 변경\nCloudflare가 Origin CA로 발급된 인증서를 신뢰하도록 강제 SSL/TLS \u0026gt; Origin Server 탭에서 PEM/KEY 파일 발급 후 /etc/nginx/key/ 디렉터리에 저장\nAuthenticated Origin Pulls 활성화\nNginx 설정 /etc/nginx/sites-available/ 디렉터리에서 기존에 사용하던 설정 파일 복사\n이전할 주소로 파일명 변경 후 파일 내용의 기존 주소를 새 주소로 변경\n/etc/nginx/sites-enabled/ 디렉터리에 심볼릭 링크로 연결\nbash 1 sudo ln -s /etc/nginx/sites-available/yourdomain.com /etc/nginx/sites-enabled/ 설정 파일 문법 검사 후 문제 없으면 nginx 리로드 bash 1 2 sudo nginx -t sudo systemctl reload nginx ","date":"2025-09-19T23:51:00+09:00","permalink":"https://kimcatchy.github.io/p/cloudflare-registrar-domain-transfer/","title":"Cloudflare Registrar 도메인 이전"},{"content":"최단경로 알고리즘 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로\n간선의 가중치는 비용, 거리, 시간 등\n최단 경로를 위한 그래프 표현: 간선이 없으면 가중치를 무한대로 처리\nDijkstra의 최단 경로 알고리즘 시작 정점 v에서 모든 다른 정점까지의 최단 경로 찾음\n시작 정점 v: 최단 경로 탐색의 시작 정점\n집합 S: 시작 정점 v로부터의 최단경로가 이미 발견된 정점들의 집합\ndist 배열: S에 있는 정점만을 거쳐서 다른 정점으로 가는 최단 거리를 기록하는 배열\n매 단계에서 최소 distance인 정점을 S에 추가\nS에 속하지 않은 정점들 중에서 dist가 가장 작은 정점을 S에 추가\n추가 후 남은 정점들의 dist를 갱신, 이 과정 반복\ndist[w] = min(dist[w], dist[u] + weight[u][w])\n파이썬 알고리즘 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def shortest_path_dijkstra(vtx, adj, start): vsize = len(vtx)\t# 정점 수 dist = list(adj[start])\t# 배열 생성 및 초기화 path = [start] * vsize found = [False] * vsize found[start] = True\t# 시작 정점: 이미 찾아짐 dist[start] = 0\t# 시작 정점의 거리 0 for i in range(vsize): print(\u0026#34;Step%2d: \u0026#34;%(i+1), dist)\t# 단계별 dist[] 출력용 u = choose_vertex(dist, found)\t# 최소 dist 정점 u 탐색 found[u] = True\t# u 찾음 for w in range(vsize):\t# 모든 정점에 대해 if not found[w]:\t# 아직 찾아지지 않았으면 if dist[u] + adj[u][w] \u0026lt; dist[w]:\t# 갱신 조건 검사 dist[w] = dist[u] + adj[u][w]\t# dist 갱신 path[w] = u\t# 이전 정점 갱신 return path\t# 찾아진 최단 경로 반환 테스트 프로그램 python 1 2 3 4 5 6 7 8 9 10 11 12 print(\u0026#34;Shortest Path by Dijkstra Algorithm\u0026#34;) start = 0 path = shortest_path_dijkstra(vertex, weight, start) # 최종 경로를 출력하기 위한 코드 for end in range(len(vertex)): if end != start: print(\u0026#34;[최단경로: %s -\u0026gt; %s] %s\u0026#34; % (vertex[start], vertex[end], vertex[end]), end=\u0026#39;\u0026#39;) while (path[end] != start): print(\u0026#34;\u0026lt;- %s\u0026#34; % vertex[path[end]], end=\u0026#39;\u0026#39;) end = path[end] print(\u0026#34;\u0026lt;- %s\u0026#34; % vertex[path[end]]) ","date":"2025-09-19T23:43:00+09:00","permalink":"https://kimcatchy.github.io/p/shortest-path-algorithm/","title":"Shortest Path Algorithm"},{"content":"가중치 그래프 Weighted Graph\n간선에 가중치가 할당된 그래프\nG =(V, E, w)\nw: 비용, 가중치, 길이 경로 p의 길이: 경로상의 모든 간선의 합\n인접 행렬을 이용한 표현 A B C D E F G A 0 29 10 B 29 0 16 15 C 16 0 12 F 12 0 22 18 E 22 0 27 25 F 10 27 0 G 15 18 25 0 python 1 2 3 4 5 6 7 # 2차원 배열 → 파이썬: 리스트의 리스트 vertex = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, ... , \u0026#39;G\u0026#39;] weight = [[None, 29, ... , None], [29, None, ... , 15], ... [None, 15, ... , None]] graph = (vertex, weight) # 전체 그래프: 튜플 사용 python 1 2 3 4 5 6 7 8 # 인접 행렬에서의 가중치의 합 계산 def weightSum(vlist, W): # 매개변수: 정점 리스트, 인접 행렬 sum = 0 # 가중치의 합 초기화 for i in range(len(vlist)): # 모든 정점에 대해 for j in range(i+1, len(vlist)): # 하나의 행에 대해 (삼각영역) if W[i][j] != None: # 간선이 있으면 sum += W[i][j] # sum에 추가 return sum # 전체 가중치 합을 반환 python 1 2 3 4 5 6 7 # 인접 행렬에서의 모든 간선 출력 def printAllEdges(vlist, W): for i in range(len(vlist)): for j in range(len(vlist)): if W[i][j] != None and W[i][j] != 0: print(\u0026#34;(%s, %s, %d)\u0026#34;%(vlist[i], vlist[j], W[i][j]), end=\u0026#39;\u0026#39;) print() 인접 리스트를 이용한 표현 python 1 2 3 4 graph = {\t\u0026#39;A\u0026#39;: set([(\u0026#39;B\u0026#39;, 29), (\u0026#39;F\u0026#39;, 10)]), \u0026#39;B\u0026#39;: set([(\u0026#39;A\u0026#39;, 29), (\u0026#39;C\u0026#39;, 16), (\u0026#39;G\u0026#39;, 16), ... \u0026#39;G\u0026#39;: set([(\u0026#39;B\u0026#39;, 15), (\u0026#39;D\u0026#39;, 18), (\u0026#39;E\u0026#39;, 25)]) } python 1 2 3 4 5 6 7 # 인접 리스트에서의 가중치의 합 계산 def weightSum(graph): sum = 0 for v in graph: for e in graph[v]: sum += e[1] return sum//2 # 하나의 간선이 두 번 더해지므로 2로 나눔 python 1 2 3 4 5 # 인접 리스트에서의 모든 간선 출력 def printAllEdges(graph): for v in graph: for e in graph[v]: print(\u0026#34;(%s, %s, %d)\u0026#34;%(v, e[0], e[1]), end=\u0026#39;\u0026#39;) 최소비용 신장트리 Minimum Spanning Tree, MST\n간선들의 가중치 합이 최소인 신장트리\n반드시 (n-1)개의 간선만 사용\n사이클이 포함되면 안됨\nMST의 응용\n도로, 통신, 배관 건설: 모두 연결하면서 길이/비용을 최소화\n전기 회로: 단자를 모두 연결하면서 전선의 길이를 최소화\nKruskal의 MST 알고리즘 탐욕적인 방법(greedy method)\n‘그 순간에 최적’이라고 생각되는 것을 선택\n각 단계에서 최선의 답을 선택 → 최종적인 해답에 도달\n항상 최적의 해답을 주는지 검증 필요함\n알고리즘 그래프의 모든 간선을 가중치에 따라 오름차순으로 정렬\n가장 가중치가 작은 간선 e를 뽑음\ne를 신장트리에 넣었을 때 사이클이 생기면 넣지 않고 2번으로 이동\n사이클이 생기지 않으면 최소 신장 트리에 삽입\nn-1개의 간선이 삽입될 때까지 2번으로 이동\nPrim의 MST 알고리즘 하나의 정점에서부터 시작하여 트리를 단계적으로 확장\n현재의 신장트리 집합에 인접한 정점 중 최저 간선으로 연결된 정점 선택하여 신장트리 집합에 추가\n이 과정을 n-1개의 간선을 가질 때까지 반복\n알고리즘 그래프에서 시작 정점을 선택하여 초기 트리를 만듦\n현재 트리의 정점들과 인접한 정점들 중에서 간선의 가중치가 가장 작은 정점 v를 선택\n이 정점 c와 이때의 간선을 트리에 추가\n모든 정점이 삽입될 때까지 2번으로 이동\nMST 알고리즘 시간 복잡도 Kruskal 알고리즘: O(e log e)\n대부분 간선들을 정렬하는 시간에 좌우됨\n간선 e개를 정렬하는 시간\nPrim의 알고리즘: O(n²)\n주 반복문이 n번, 내부 반복문이 n번 반복 희박한 그래프: O(e log e)인 Kruskal이 유리\n밀집한 그래프: O(n²)인 Prim이 유리\n","date":"2025-09-19T23:37:00+09:00","permalink":"https://kimcatchy.github.io/p/weighted-graph-and-minimum-cost/","title":"가중치 그래프의 표현 \u0026 최소비용"},{"content":"그래프 연결되어 있는 객체 간의 관계를 표현하는 자료구조\n가장 일반적인 자료구조 형태\n오일러 정리: 모든 정점에 연결된 간선의 수가 짝수이면 오일러 경로 존재함\n그래프 정의 그래프 G는 (V, E)로 표시\n정점(Vertices) 또는 노드(Node)\n간선(Edge) 또는 링크(Link): 정점들 간의 관계 의미\n시각적으로 달라 보여도 모든 정점 사이의 관계가 동일하다면 같은 그래프\n그래프의 종류 무방향 그래프\n(A, B) = (B, A)\nV(G) = {A, B, C, D}\nE(G) = {(A, B), (A, C), (A, D), (B, C), (C, D)}\n방향 그래프\n\u0026lt;A, B\u0026gt; ≠ \u0026lt;B, A\u0026gt; 가중치 그래프, 네트워크: 간선에 비용이나 가중치가 할당된 그래프\n부분 그래프: 그래프의 일부만 포함된 그래프\n그래프 관련 용어 인접 정점: 간선에 의해 직접 연결된 정점\n차수: 정점에 연결된 간선의 수\n무방향 그래프에서 차수의 합은 간선 수의 2배\n방향 그래프에서 모든 진입(진출)차수의 합은 간선의 수\n그래프의 경로: 한 정점에서 다른 정점까지의 경로\n경로의 길이: 경로를 구성하는데 사용된 간선의 수\n단순 경로: 경로 중에서 반복되는 간선이 없는 경로\n사이클(순환): 시작 정점과 종료 정점이 동일한 경로\n연결 그래프: 모든 정점들 사이에 경로가 존재하는 그래프\n트리: 사이클을 가지지 않는 연결 그래프\n완전 그래프: 모든 정점 간에 간선이 존재하는 그래프\nn개의 정점을 가진 무방향 완전 그래프의 간선의 수 = n × (n-1) ÷ 2 그래프 ADT isEmpty(): 그래프가 공백 상태인지 확인\ncountVertex(): 정점의 수를 반환\ncountEdge(): 간선의 수를 반환\ngetEdge(u, v): 정점 u에서 정점 v로 연결된 간선을 반환\ndegree(v): 정점 v의 차수를 반환\nadjacent(v): 정점 v에 인접한 모든 정점의 집합을 반환\ninsertVertex(v): 그래프에 정점 v를 삽입\ninsertEdge(u, v): 그래프에 간선 (u, v)를 삽입\ndeleteVertex(v): 그래프의 정점 v를 삭제\ndeleteEdge(u, v): 그래프의 간선 (u, v)를 삭제\n그래프의 표현 인접 행렬을 이용한 표현 인접 행렬 M을 이용\n간선 (i, j)가 있으면 M[i][j] = 1 or true, 없으면 M[i][j] = 0 or false\n무방향 그래프는 인접 행렬이 대칭 ((A, B) = (B, A)이니까)\n인접 리스트를 이용한 표현 각 정점마다 연결된 정점, 화살표가 없으면 None 인접 행렬과 인접 리스트의 복잡도 비교 정점의 수가 n이고 간선의 수가 e인 무방향 그래프 인접 행렬 인접 리스트 간선의 수에 무관하게 항상 n²개의 메모리 공간이 필요함 따라서 정점에 비해 간선의 수가 매우 많은 조밀 그래프에서 효과적 n개의 연결 리스트가 필요하고, 2e개의 노드가 필요함 즉 n+2e개의 메모리 고안이 필요함 따라서 정점에 비해 간선의 개수가 매우 적은 희소 그래프에서 효과적 u와 v를 연결하는 간선의 유무는 M[u][v]를 조사하면 바로 알 수 있음 따라서 getEdge(u, v) 정점 u의 차수를 dᵤ라고 한다면 연산의 시간 복잡도는 O(dᵤ) 정점의 차수를 구하는 degree(v) 정점 v의 인접 정점을 구하는 adjacent(v) 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야 하므로 O(n) 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접 리스트를 조사해야 하므로 O(n+e)의 연산이 요구됨 그래프의 탐색 가장 기본적인 연산: 시작 정점부터 차례대로 모든 정점들을 한 번씩 방문\n많은 문제들이 단순히 탐색만으로 해결됨\n도로망 예: 특정 도시에서 다른 도시로 갈 수 있는지 여부\n전자회로 예: 특정 단자와 다른 단자의 연결 여부\n깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)\n깊이 우선 탐색(DFS) Depth-First Search\n한 방향으로 끝까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색 진행\n되돌아가기 위해서는 스택 필요 (순환함수 호출로 묵시적인 스택 이용)\npython 1 2 3 4 5 6 7 def dfs(graph, start, visited = set()):\t# 처음 호출할 때 visited 공집합 if start not in visited:\t# start가 방문하지 않은 정점이면 visited.add(start)\t# start를 방문한 노드 집합에 추가 print(start, end=\u0026#39;\u0026#39;)\t# start를 방문했다고 출력 nbr = graph[start] - visited\t# nbr: 차집합 연산 이용 for v in nbr: dfs(graph, v, visited) 한 번 방문한 정점은 다시 탐색하지 않아야 하므로 방문한 정점을 관리하는 집합(또는 리스트) 필요\n탐색이 시작되면 시작 정점에서부터 임의의 인접한 정점으로 탐색을 진행, 한번 방문한 정점은 반드시 visited에 넣어야 함\n한 정점에서의 탐색은 그 정점과 인접한 정점들 중에서 아직 방문하지 않은 정점으로만 가능\n만약 어떤 정점에서 더 이상 방문하지 않은 인접 정점을 찾아 다시 동일한 방법으로 탐색을 진행\n이 방법은 가장 최근에 만났던 갈림길로 되돌아가야 하므로 스택을 사용하여 구현 너비 우선 탐색(BFS) Breadth-First Search\n시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법\n큐를 사용하여 구현\npython 1 2 3 4 5 6 7 8 9 10 def bfs(graph, start): visited = set([start]) queue = collections.deque([start]) while queue: vertex = queue.popleft() print(vertex, end=\u0026#39;\u0026#39;) nbr = graph[vertex] - visited for v in nbr: visited.add(v) queue.append(v) 가까운 정점들을 차례로 저장하고, 들어간 순서대로 꺼낼 수 있는 자료구조가 필요 (큐)\n정점들이 방문될 때마다 큐에 인접 정점을 삽입하고, 더 이상 방문할 인접 정점이 없는 경우 큐의 맨 앞에서 정점을 꺼내 그 정점과 인접한 정점을 차례대로 방문\n초기 상태의 큐에는 시작 정점만이 저장되어 있고, 너비 우선 탐색 과정은 큐가 공백 상태가 될 때까지 계속\n탐색 알고리즘 성능 깊이 우선 탐색 / 너비 우선 탐색\n인접 행렬 표현: O(n²)\n인접 리스트로 표현: O(n+e)\n완전 그래프와 같은 조밀 그래프 → 인접 행렬이 유리\n희소 그래프 → 인접 리스트가 유리\n신장 트리 그래프 내의 모든 정점을 포함하는 트리\n사이클을 포함하면 안됨\n간선의 수 = n-1\n깊이 우선 신장 트리, 너비 우선 신장 트리\n신장 트리 알고리즘 python 1 2 3 4 5 6 7 8 9 10 def bfsST(graph, start): visited = set([start]) queue = collections.deque([start]) while queue: v = queue.popleft() nbr = graph[v] - visited\t# v의 인접 정점에서 방문 정점 제외 for u in nbr:\t# 갈 수 있는 모든 인접 정점에 대해 print(\u0026#34;(\u0026#34;, v, \u0026#34;,\u0026#34;, u, \u0026#34;)\u0026#34;, end=\u0026#39;\u0026#39;)\t# (v, u) 간선 추가 visited.add(u) queue.append(u) 위상 정렬 방향 그래프에 대해 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것\n진입차수가 0인 정점을 선택하여 삭제하고, 간선으로 연결된 간선의 차수 변경\n","date":"2025-09-19T23:29:00+09:00","permalink":"https://kimcatchy.github.io/p/ds-graph/","title":"Graph"},{"content":"이진탐색트리 효율적인 탐색을 위한 이진트리 기반의 자료구조\n삽입, 삭제, 탐색: O(log n)\n모든 노드는 유일한 키를 가짐\n왼쪽 서브트리의 키들은 루트의 키보다 작음\n오른쪽 서브트리의 키들은 루트의 키보다 큼\n왼쪽과 오른쪽 서브트리도 이진 탐색트리\n이진탐색트리의 연산 노드의 구조 탐색키, 키에 대한 값의 형태 python 1 2 3 4 5 6 class BSTNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None 탐색 연산 키를 이용한 탐색\n루트를 기준으로 작으면 왼쪽 자식부터, 크면 오른쪽 자식부터 다시 탐색\n과정을 반복하며 탐색키와 동일한 키를 찾을 경우 탐색 성공, 못 찾으면 탐색 실패\n순환 구조와 반복 구조로 구현할 수 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 이진트리탐색 탐색연산 (순환 함수) def search_bst(n, key): if n == None: return None elif key == n.key: return n elif key \u0026lt; n.key: return search_bst(n.left, key) else: return search_bs(n.right, key) # 이진트리탐색 탐색연산 (반복 함수) def search_bst_iter(n, key): while n != None: if key == n.key: return n elif key \u0026lt; n.key: n = n.left else: n = n.right return None 값을 이용한 탐색일 경우 모든 노드를 검사해야 함\n최대/최소 값의 노드 탐색\npython 1 2 3 4 5 6 7 8 9 def search_max_bst(n): while n != None and n.right != None: n = n.right return n def search_min_bst(n): while n != None and n.left != None: n = n.left return n 삽입 연산 탐색에 실패한 위치 = 노드를 삽입해야 하는 위치 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 이진탐색트리 삽입연산 (노드 삽입): 순환구조 이용 def insert_bst(r, n): # 삽입할 노드의 키가 루트보다 작으면 if n.key \u0026lt; r.key: # 루트의 왼쪽 자식이 없으면 n은 루트의 왼쪽 자식이 됨 if r.left is None: r.left = n return True # 왼쪽 자식이 있으면 왼쪽 자식에게 삽입 else: return insert_bst(r.left, n) # 삽입할 노드의 키가 루트보다 크면 elif n.key \u0026gt; r.key: # 루트의 오른쪽 자식이 없으면 n은 루트의 오른쪽 자식이 됨 if r.right is None: r.right = n return True # 오른쪽 자식이 있으면 오른쪽 자식에게 삽입 else: return insert_bst(r.right, n) # 키가 중복되면 삽입하지 않음 else: retrun false 삭제 연산 삭제하려는 노드가 단말 노드일 경우 python 1 2 3 4 5 6 7 8 9 10 def delete_bst_case1(parent, node, root): if parent is None: root = None else: if parent.left == node: parent.left = None else: parent.right = None # root가 변경될 수도 있으므로 반환 return root 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우 python 1 2 3 4 5 6 7 8 9 10 11 12 13 def delete_bst_case2(parent, node, root): if node.left is not None: child = node.left else: child = node.right if node == root: root = child else: if node is parent.left: parent.left = child else: parent.right = child return root 삭제하려는 노드가 두 개의 서브 트리를 모두 가지고 있는 경우\n가장 비슷한 값을 가진 노드를 삭제 위치로 가져옴\n삭제할 위치에 왼쪽 서브트리의 가장 큰 노드나 오른쪽 서브트리의 가장 작은 노드가 들어가면 이진탐색트리의 조건을 계속 만족함 후계 노드의 선택\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def delete_bst_case3(parent, node, root): succp = node succ = node.right while (succ.left != None): succp = succ succ = succ.left if (succp.left == succ): succp.left = succ.right else: succp.right = succ.right node.key - succ.key node.value = succ.value node = succ return root 삭제 연산 전체 코드 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def delete_bst(root, key): if root == None: return None parent = None node = root while node != None and node.key != key: parent = node if key \u0026lt; node.key: node = node.left else: node = node.right if node == None: return None\t# 삭제할 노드가 없으면 None if node.left == None and node.right == None: root = delete_bst_case1(parent, node, root) elif node.left == None or node.right == None: root = delete_bst_case2(parent, node, root) else: root = delete_bst_case3(parent, node, root) return root 이진탐색트리의 성능 탐색, 삽입, 삭제 연산의 시간 트리의 높이에 비례 연산 함수 최선의 경우 (균형) 최악의 경우 (경사) 키를 이용한 탐색 search_bst() search_bst_iter() O(log₂n) O(n) 값을 이용한 탐색 search_value_bst() O(n) O(n) 최대/최소 노드 탐색 search_max_bst() search_min_bst() O(log₂n) O(n) 삽입 insert_bst() O(log₂n) O(n) 삭제 delete_bst() O(log₂n) O(n) AVL 트리 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1을 넘지 않는 이진탐색\n모든 노드의 균형 인수는 0이나 ±1이 되어야 함\n균형 인수: 왼쪽 서브트리 높이 - 오른쪽 서브트리 높이\n평균, 최선, 최악 시간 복잡도: O(log n) 보장\nAVL 트리의 연산 탐색 연산은 이진탐색트리와 동일\n삽입과 삭제 시 균형 상태가 깨질 수 있음\n삽입 연산 삽입 위치에서 루트까지의 경로에 있는 조상 노드들의 균형 인수에 영향을 미침\n삽입 후에 불균형 상태로 변한 가장 가까운 조상 노드(균형 인수가 ±2가 된 가장 가까운 조상 노드)의 서브 트리들에 대하여 다시 재균형\n삽입 노드부터 균형 인수가 ±2가 된 가장 가까운 조상 노드까지 회전\n균형이 깨지는 4가지 경우: LL, LR, RR, RL 타입\n새로 삽입된 노드 N으로부터 가장 가까우면서 균형인수가 ±2가 된 조상 노드를 A라고 할 때 단순 회전\nLL 타입\n불균형 노드의 왼쪽 서브트리의 왼쪽 서브트리의 높이 증가\nN이 A의 왼쪽 자식의 왼쪽 서브 트리에 삽입됨\nLR 타입\n불균형 노드의 왼쪽 서브트리의 오른쪽 서브트리의 높이 증가\nN이 A의 왼쪽 자식의 오른쪽 서브 트리에 삽입됨\n이중 회전\nRR 타입\n불균형 노드의 오른쪽 서브트리의 왼쪽 서브트리의 높이 증가\nN이 A의 오른쪽 자식의 오른쪽 서브 트리에 삽입됨\nRL 타입\n불균형 노드의 오른쪽 서브트리의 오른쪽 서브트리의 높이 증가\nN이 A의 오른쪽 자식의 왼쪽 서브 트리에 삽입됨\n탐색 순서를 유지하면서 부모와 자식의 위치를 교환\npython 1 2 3 4 5 6 7 # LL 회전 def rotateLL(A): B = A.left A.left = B.right B.right = A # 새로운 루트 B를 반환 return B python 1 2 3 4 5 6 # RR 회전 def rotateRR(A): B = A.right A.right = B.left B.left = A return B python 1 2 3 4 5 # RL 회전 def rotateRL(A): B = A.right A.right = rotateLL(B) return rotateRR(A) python 1 2 3 4 5 # LR 회전 def rotateLR(A): B = A.left A.left = rotateRR(B) return rotateLL(A) 재균형 함수 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def reBalance(parent): hDiff = calc_height_diff(parent) if hDiff \u0026gt; 1: if calc_height_diff(parent.left) \u0026gt; 0: parent = rotateLL(parent) else: parent = rotateLR(parent) elif hDiff \u0026lt; -1: if calc_height_diff(parent.right) \u0026lt; 0: parent = rotateRR(parent) else: parent = rotateRL(parent) return parent AVL 트리의 삽입 함수 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def insert_avl(parent, node): if node.key \u0026lt; parent.key: if parent.left != None: parent.left = insert_avl(parent.left, node) else: parent.left = node return reBalance(parent) elif node.key \u0026gt; parent.key: if parent.right != None: parent.right = insert_avl(parent.right, node) else: parent.right = node return reBalance(parent) else: print(\u0026#34;중복된 키 에러\u0026#34;) AVL 트리의 균형 장점: 탐색 효율 O(log n)을 보장해줌\n단점: 삽입/삭제 될 때마다 균형 파괴 여부 검사(균형 인수 값을 구하는 시간) 필요, 트리를 재구성하는 시간 필요\n균형 트리\nBalanced Tree\n탐색 효율 O(log n)을 보장\n루트로부터 리프까지 가는 경로를 최소화\n자체 조정 트리\n무조건 균형보다는 자주 탐색되는 노드는 또 탐색될 확률이 높으므로 루트 근처에 위치시킴 자체 조정 트리를 만드는 방법 조정 방법 ①: 어떤 노드가 탐색될 때마다 그 노드를 바로 위 부모 노드로 올리는 방법 (한 번의 회전)\n조정 방법 ②:어떤 노드가 탐색될 때마다 전체 트리의 루트로 올리는 방법 (연속된 회전 필요)\n문제점: 조정 방법 ②의 한계로 트리의 균형 면에서 불리함\n스플레이 기법 스플레이(Splay): 조정 방법 ②를 개선하여 탐색된 노드를 루트로 올리되, 한 번에 두 레벨 씩 위로 올림\n자체 조정 트리에서 어떤 노드가 탐색되면 그 노드를 아예 전체 트리의 루트로 올리는 방법\n지그재그 LL/RR: 올리고자 하는 노드가 그보다 두 레벨 위의 노드로부터 LR/RL 경로로 따라 내려올 때\nAVL의 LR/RL 회전과 완전히 동일 References Tree rotation ","date":"2025-09-19T23:17:00+09:00","permalink":"https://kimcatchy.github.io/p/search-tree/","title":"Search Tree"},{"content":"힙 Heap\n\u0026lsquo;더미\u0026rsquo;와 모습이 비슷한 완전 이진트리 기반의 자료 구조\n가장 큰(또는 작은) 값을 빠르게 찾아내도록 만들어진 자료 구조\n최대 힙: 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리\n최소 힙: 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리\n힙의 연산 삽입 연산 - upheap 회사에서 신입 사원이 들어오면 일단 말단 위치에 앉히고 능력을 봐서 위로 승진시킴\n부모 노드와 비교해서 더 클 경우 교환(sift-up)\n시간 복잡도: O(log n)\n삭제 연산 - downheap 회사에서 사장 자리가 비면 일단 사장 자리에 앉히고 순차적으로 강등시킴\n자식 노드 중 더 큰 자식 노드와 비교해서 더 작을 경우 교환(sift-down)\n힙의 구현 보통 배열을 이용하여 구현\n완전 이진트리 → 각 노드에 번호를 붙임 → 배열의 인덱스 부모 노드와 자식 노드의 관계\n왼쪽 자식의 인덱스 = (부모의 인덱스)*2\n오른쪽 자식의 인덱스 = (부모의 인덱스)*2 + 1\n부모의 인덱스 = (자식의 인덱스)/2\n최대 힙 클래스 python 1 2 3 4 5 6 7 8 9 10 11 class MaxHeap: def __init__(self): self.heap = []\t# 리스트(배열)을 이용한 힙 self.heap.append(0)\t# 0번 항목은 사용하지 않음 def size(self): return len(self.heap) - 1 def isEmpty(self): return self.size() == 0 def Parent(self, i): return self.heap[i//2] def Left(self, i): return self.heap[i*2] def Right(self, i): return self.heap[i*2+1] def display(self, msg=\u0026#39;힙 트리: \u0026#39;): print(msg, self.heap[1:]) 삽입 연산 python 1 2 3 4 5 6 7 8 def insert(self, n): self.heap.append(n) i = self.size() # 부모보다 큰 동안 계속 업힙 while (i != 1 and n \u0026gt; self.Parent(i)): self.heap[i] = self.Parent(i) i = i//2 self.heap[i] = n 삭제 연산 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def delete(self): parent = 1 child = 2 if not self.isEmpty(): hroot = self.heap[1] last = self.heap[self.size()] while (child \u0026lt;= self.size()): # 만약 오른쪽 노드가 더 크면 child를 1 증가 (기본은 왼쪽 노드) if child \u0026lt; self.size() and self.Left(parent) \u0026lt; self.Right(parent):child += 1 if last \u0026gt; = self.heap[child]: break self.heap[parent] = self.heap[child] parent = child child *= 2 self.heap[parent] = last self.heap.pop(-1) return hroot 테스트 프로그램 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MaxHeap: def __init__(self): self.heap = [] self.heap.append(0) def size(self): return len(self.heap) - 1 def isEmpty(self): return self.size() == 0 def Parent(self, i): return self.heap[i//2] def Left(self, i): return self.heap[i*2] def Right(self, i): return self.heap[i*2+1] def display(self, msg=\u0026#39;힙 트리: \u0026#39;): print(msg, self.heap[1:]) def insert(self, n): self.heap.append(n) i = self.size() while (i != 1 and n \u0026gt; self.Parent(i)): self.heap[i] = self.Parent(i) i = i//2 self.heap[i] = n def delete(self): parent = 1 child = 2 if not self.isEmpty(): hroot = self.heap[1] last = self.heap[self.size()] while (child \u0026lt;= self.size()): if child \u0026lt; self.size() and self.Left(parent) \u0026lt; self.Right(parent):child += 1 if last \u0026gt;= self.heap[child]: break self.heap[parent] = self.heap[child] parent = child child *= 2 self.heap[parent] = last self.heap.pop(-1) return hroot heap = MaxHeap() data = [2, 5, 4, 8, 9, 3, 7, 3] print(\u0026#34;[삽입 연산]: \u0026#34; + str(data)) for elem in data: heap.insert(elem) heap.display(\u0026#39;[삽입 후]: \u0026#39;) heap.delete() heap.display(\u0026#39;[삭제 후]: \u0026#39;) heap.delete() heap.display(\u0026#39;[삭제 후]: \u0026#39;) bash 1 2 3 4 [삽입 연산]: [2, 5, 4, 8, 9, 3, 7, 3] [삽입 후]: [9, 8, 7, 3, 5, 3, 4, 2] [삭제 후]: [8, 5, 7, 3, 2, 3, 4] [삭제 후]: [7, 5, 4, 3, 2, 3] 힙의 복잡도 분석 삽입 연산에서 최악의 경우\n루트 노드에서 올라가야 하므로 트리의 높이 해당하는 비교 연산 및 이동 연산 필요\nO(log n)\n삭제 연산에서 최악의 경우\n가장 아래 레벨까지 내려가야 하므로 역스 트리의 높이 만큼의 시간이 걸림\nO(log n)\n힙의 응용 허프만 코드\n이진트리는 각 글자의 빈도가 알려져 있는 메시지의 내용을 압축하는데 사용될 수 있음\n이런 종류의 이진트리를 허프만 코딩 트리라고 함\n허프만 코딩 트리 생성 프로그램\npython 1 2 3 4 5 6 7 8 9 10 11 12 def make_tree(freq): heap = MinHeap() for n in freq: heap.insert(n) for i in range (0, n): e1 = heap.delete() e2 = heap.delete() heap.insert(e1 + e2) print(\u0026#34; (%d+%d)\u0026#34; % (e1, e2)) label = [\u0026#39;E\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;S\u0026#39;] freq = [15, 12, 8, 6, 4] make_tree(freq) ","date":"2025-09-19T23:10:00+09:00","permalink":"https://kimcatchy.github.io/p/ds-heap/","title":"Heap"},{"content":"트리 계층적인 자료의 표현에 적합한 자료 구조\n트리의 모든 노드는 자신의 서브트리의 루트 노드\n연결된 위 레벨의 노드는 부모 노드, 아래 레벨의 노드는 자식 노드\n단말 노드: 자손이 없는 노드, 자손이 있으면 비단말 노드\n차수: 해당 노드의 자식 노드의 수\n트리의 차수: 트리를 구성하고 있는 각 노드의 차수 중 가장 높은 차수\n이진트리 모든 노드가 2개의 서브 트리를 갖는 트리\n공집합이거나 루트와 왼쪽/오른쪽 서브 트리로 구성된 노드들의 집합\n순환적으로 정의됨\n서브트리는 공집합일 수 있음\n이진트리의 서브 트리들은 모두 이진트리이어야 함\n이진트리의 분류 포화 이진트리 (Full Binary Tree)\n트리의 각 레벨에 노드가 꽉 차 있는 이진트리 완전 이진트리 (Complete Binary Tree)\n높이가 h일 때 레벨 1부터 h-1까지는 노드가 모두 채워짐\n마지막 레벨 h에서는 노드가 순서대로 채워짐\n경사 이진트리\n왼쪽으로만 자식 노드가 일렬로 늘어 놓인 이진트리 이진트리의 성질 노드의 개수가 n개이면 간선의 개수는 n-1 (루트 노드는 부모가 없음)\n높이가 h이면 h ~ 2ʰ-1개의 노드를 가짐 (각 레벨에 최소 하나의 노드가 있어야 함)\nn개 노드의 이진트리 높이 = \\[log₂ (n+1)\\] ~ n\n이진트리의 표현 배열 표현법: 높이가 K일 때 필요한 배열의 길이 = 2ᵏ-1\n높이 i의 부모 노드 인덱스 = i//2 (정수 나눗셈)\n노드 i의 왼쪽 자식 노드 인덱스 = 2i\n노드 i의 오른쪽 자식 노드 인덱스 wi+1\n링크 표현법: 데이터의 왼쪽과 오른쪽에 각각 자식노드의 링크\n링크 2개만 있으면 표현이 가능함\n경사 이진트리에서 화살표가 없는 링크는 None을 가짐\npython 1 2 3 4 5 class Tnode: def __init__(self, data, left, right): self.data = data self.left = left self.right = right 순회 Traversal\n트리에 속하는 모든 노드를 한 번씩 방문하는 것\n선형 자료구조는 순회가 단순\n트리는 다양한 방법이 있음\n이진트리의 기본 순회 (루트 노드가 V, 왼쪽 서브트리가 L, 오른쪽 서브트리가 R)\n전위 순회(Preorder Traversal): VLR\n중위 순회(Inorder Traversal): LVR\n후위 순회(Postorder Traversal): LRV\n전위 순회 Preorder Traversal\n루트 → 왼쪽 서브트리 → 오른쪽 서브트리\n응용 예: 노드의 레벨 계산, 구조화된 문서 출력\npython 1 2 3 4 5 def preorder(n): if n is not None: print(n.data, end=\u0026#39;\u0026#39;) preorder(n.left) preorder(n.right) 중위 순회 Inorder Traversal\n왼쪽 서브트리 → 루트 → 오른쪽 서브트리\n응용 예: 정렬\npython 1 2 3 4 5 def inorder(n): if n is not None: preorder(n.left) print(n.data, end=\u0026#39;\u0026#39;) preorder(n.right) 후위 순회 Postorder Traversal\n왼쪽 서브트리 → 오른쪽 서브트리 → 루트\n응용 예: 폴더 용량 계산\npython 1 2 3 4 5 def postorder(n): if n is not None: preorder(n.left) preorder(n.right) print(n.data, end=\u0026#39;\u0026#39;) 레벨 순회 노드를 레벨 순으로 검사하는 순회 방법\n큐를 사용해 구현\n순환을 사용하지 않음\npython 1 2 3 4 5 6 7 8 9 def levelorder(root): queue = CircularQueue() queue.enqueue(root) while not queue.isEmpty(): n = queue.dequeue() if n is not None: print(n.data, end=\u0026#39;\u0026#39;) queue.enqueue(n.left) queue.enqueue(n.right) 이진트리 연산 노드 개수 python 1 2 3 4 5 def count_node(n):\t# 순환을 이용해 트리의 노드 수를 계산하는 함수 if n is None:\t# n이 None이면 공백 트리 → 0을 반환 return 0 else:\t# 좌우 서브트리의 노드수의 합+1을 반환 (순환이용) return 1 + count_node(n.left) + count_node(n.right) 단말 노드의 수 python 1 2 3 4 5 6 7 def count_leaf(n): if n is None:\t# 공백 트리 → 0을 반환 return 0 elif n.left is None and n.right is None:\t# 단말 노드 → 1을 반환 return 1 else:\t# 비단말 노드 → 좌우 서브트리의 결과 합을 반환 return count_leaf(n.left) + count_leaf(n.right) 트리 높이 python 1 2 3 4 5 6 7 8 9 def calc_height(n): if n is None:\t# 공백 트리 → 0을 반환 return 0 hLeft = calc_height(n.left)\t# 왼쪽 트리의 높이 hRight = calc_height(n.right)\t# 오른쪽 트리의 높이 if (hLeft \u0026gt; hRight):\t# 더 높은 높이에 1을 더해 반환 return hLeft + 1 else: return hRight + 1 테스트 프로그램 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 import queue class CircularQueue: def __init__(self): self.q = queue.Queue(maxsize=10) self.front = 0 self.rear = 0 def isEmpty(self): return self.q.empty() def isFull(self): return self.q.full() def clear(self): self.q = queue.Queue(maxsize=10) self.front = 0 self.rear = 0 def enqueue(self, item): if not self.isFull(): self.q.put(item) self.rear = (self.rear + 1) % 10 def dequeue(self): if not self.isEmpty(): item = self.q.get() self.front = (self.front + 1) % 10 return item def peek(self): if not self.isEmpty(): return list(self.q.queue)[0] def size(self): return self.q.qsize() def display(self): items = list(self.q.queue) print(f\u0026#39;[f={self.front}, r={self.rear}] ==\u0026gt; \u0026#39;, items) class Tnode: def __init__(self, data, left, right): self.data = data self.left = left self.right = right def preorder(n): if n is not None: print(n.data, end=\u0026#39;\u0026#39;) preorder(n.left) preorder(n.right) def inorder(n): if n is not None: preorder(n.left) print(n.data, end=\u0026#39;\u0026#39;) preorder(n.right) def postorder(n): if n is not None: preorder(n.left) preorder(n.right) print(n.data, end=\u0026#39;\u0026#39;) def levelorder(root): queue = CircularQueue() queue.enqueue(root) while not queue.isEmpty(): n = queue.dequeue() if n is not None: print(n.data, end=\u0026#39;\u0026#39;) queue.enqueue(n.left) queue.enqueue(n.right) def count_node(n): if n is None: return 0 else: return 1 + count_node(n.left) + count_node(n.right) def count_leaf(n): if n is None: return 0 elif n.left is None and n.right is None: return 1 else: return count_leaf(n.left) + count_leaf(n.right) def calc_height(n): if n is None: return 0 hLeft = calc_height(n.left) hRight = calc_height(n.right) if (hLeft \u0026gt; hRight): return hLeft + 1 else: return hRight + 1 d = Tnode(\u0026#39;D\u0026#39;, None, None) e = Tnode(\u0026#39;E\u0026#39;, None, None) b = Tnode(\u0026#39;B\u0026#39;, d, e) f = Tnode(\u0026#39;F\u0026#39;, None, None) c = Tnode(\u0026#39;C\u0026#39;, f, None) root = Tnode(\u0026#39;A\u0026#39;, b, c) print(\u0026#39;\\\\n In-Order: \u0026#39;, end=\u0026#39;\u0026#39;) inorder(root) print(\u0026#39;\\\\n Pre-Order: \u0026#39;, end=\u0026#39;\u0026#39;) preorder(root) print(\u0026#39;\\\\n Post-Order: \u0026#39;, end=\u0026#39;\u0026#39;) postorder(root) print(\u0026#39;\\\\n Level-Order: \u0026#39;, end=\u0026#39;\u0026#39;) levelorder(root) print(\u0026#34;\\\\n노드의 개수 = %d개\u0026#34; % count_node(root)) print(\u0026#34;단말의 개수 = %d개\u0026#34; % count_leaf(root)) print(\u0026#34;트리의 높이 = %d\u0026#34; % calc_height(root)) bash 1 2 3 4 5 6 7 In-Order: BDEACF Pre-Order: ABDECF Post-Order: BDECFA Level-Order: ABCDEF 노드의 개수 = 6개 단말의 개수 = 3개 트리의 높이 = 3 ","date":"2025-09-19T20:16:00+09:00","permalink":"https://kimcatchy.github.io/p/tree-and-binary-tree/","title":"Tree \u0026 Binary Tree"},{"content":"탐색 탐색: 테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업\n맵, 딕셔너리: 탐색을 위한 자료구조, 엔트리 또는 키를 가진 레코드의 집합\n엔트리\n키: 영어 단어와 같은 레코드를 구분할 수 있는 탐색키\n값: 단어의 의미와 같이 탐색키와 관련된 값\n맵 ADT 데이터: 키를 가진 레코드(엔트리)의 집합\n연산\nsearch(key): 탐색기 key를 가진 레코드를 찾아 반환\ninsert(entry): 주어진 entry를 맵에 삽입\ndelete(key): 탐색기 key를 가진 레코드를 찾아 삭제\n맵을 구현하는 방법\n리스트 이용: 정렬 / 비정렬 (가장 간단한 구현 방법)\n이진 탐색 트리 이용: 탐색 성능을 향상 시키고자 하는 경우\n해싱 구조 이용: 맵을 구현하기 가장 좋은 방법\n순차 탐색 Sequential Search\n정렬되지 않은 배열에 적용 가능\n정렬되지 않은 배열을 처음부터 마지막까지 하나씩 검사\n가장 간단하고 직접적인 탐색 방법\n평균 비교 횟수: (n+1)/2번 비교 (최악의 경우: n번)\npython 1 2 3 4 5 def sequential_search(A, key, low, high): for i in range(low, high+1): if A[i].key == key: return i return None 탐색의 성능(비교횟수): 찾는 항목이 맨 앞에 있는 경우 1, 맨 뒤에 있는 경우 n\n평균비교횟수: (n+1)/2\n시간복잡도: O(n)\n순차 탐색의 특징\n정렬되어 있지 않는 자료에 대한 검색\n구현이 간단\n효율적이지는 않음\n이진 탐색 Binary Search\n자료가 키값을 기준으로 정렬되어 있다면 보다 개선된 탐색이 가능\n정렬된 배열의 탐색에 적합\n배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄여가며 탐색 진행\ne.g. 사전에서 단어 찾기\npython 1 2 3 4 5 6 7 8 9 10 def binary_search(A, key, low, high): if (low \u0026lt;= high): middle = (low + high) // 2\t# 정수 나눗셈 // if key == A[middle].key: return middle elif (key \u0026lt; A[middle].key): return binary_search(A, key, low, middle-1) else: return binary_search(A, key, middle+1, high) return None 탐색의 성능(비교횟수): 각 단계에서 탐색 범위가 반으로 줄어듦\n탐색 범위가 1이 될 때까지 횟수를 k라 하면 n/2ᵏ=1이 됨\nk = log 2n이므로 이진 탐색의 시간 복잡도 O(log n)\n반복으로 구현 가능\n보간 탐색 Interpolation Search\n탐색키가 존재할 위치를 예측하여 탐색\n리스트를 불균등하게 분할하여 탐색\n탐색 값과 위치는 비례한다는 가정\n탐색위치 = low + (high - low) · (찾고자하는값 - A[low]) / (A[high] - A[low])\nmiddle = int(low + (high - low) * (key - A[low].key) / A[high].key - A[low].key))\n보간 탐색은 이진 탐색과 같은 시간 복잡도 O(log n)을 갖지만 많은 데이터가 비교적 균등하게 분포되어 있는 자료의 경우 훨씬 효율적인 방법\n해싱 키 값에 대한 산술적 연산에 의해 테이블의 주소를 계산\n해시 테이블: 키 값의 연산에 의해 직접 접근이 가능한 구조, 해시 함수에 의해 계산된 위치에 저장한 테이블\n해시 함수: 탐색 키를 입력받아 해시 주소 생성\n충돌: 서로 다른 키가 해시 함수에 의해 같은 주소로 계산되는 상황\n오버플로우: 충돌이 슬롯 수보다 많이 발생하는 것\n선형 조사 선형 조사에 의한 오버플로우 처리: 충돌이 일어나면 해시 테이블의 다음 위치에 저장\n다음 항목을 순서대로 조사: h(k), h(k)+1, h(k)+2, \u0026hellip;\n빈 곳이 있으면 저장\n해시함수 h(k) = k % M (M: 해시 테이블의 크기)\nM의 값이 같으면(나머지가 같으면) 충돌이 발생하므로 13과 같은 소수를 사용하는 것이 좋음\n삽입 연산 키에 대한 해시 값을 계산하고 계산된 해시 값에 해당하는 버킷이 비어있는지 확인\n비어있다면 해당 위치에 키-값 쌍을 저장, 비어있지 않다면(충돌 발생) 다음 버킷으로 이동\n빈 버킷을 찾을 때까지 위 과정 반복\n선형 조사법은 간단하지만 오버플로우가 자주 발생하여 군집화 현상에 따라 탐색 효율이 저하됨\n탐색 연산 삽입과 비슷한 과정\n탐색키가 입력되면 해시 주소를 계산하고 해당 주소에 같은 키의 레코드가 탐색이 성공\n해당 주소에 같은 키의 레코드가 없으면 삽입과 같은 방법으로 계속 다음 버킷 검사\n이 과정은 해당 레코드를 찾거나, 레코드가 없는 버킷을 만나거나 모든 버킷을 다 검사할 때까지 진행\n삭제 연산 빈 버킷을 두 가지로 분류해야 함\n한 번도 사용하지 않는 것\n사용하였다가 삭제되어 현재 비어있는 버킷\n탐색 과정은 한 번도 사용이 안 된 버킷을 만나야만 중단됨\n군집화 완화 방법 이차 조사법 (Quadratic Probing)\n(h(k) + i²) % M, (i = 0, 1, \u0026hellip; , M-1)\n조사되는 위치는 h(k), h(k)+1, h(k)+4, \u0026hellip; , h(k)+(M-1)²\n이중 해싱법 (Double Hashing)\n재해싱(rehashing)\n충돌이 발생하면, 다른 해시 함수를 이용해 다음 위치 계산\n체이닝에 의한 오버플로우 처리 하나의 버킷에 여러 개의 레코드를 저장할 수 있도록 하는 방법\n해시 테이블의 각 버킷에 여러 개의 키-값 쌍을 저장\n충돌이 발생하면 같은 해시 값을 가진 항목들을 연결 리스트 형태로 연결\n해시 함수 좋은 해시 함수의 조건\n충돌이 적어야 함\n함수 값이 테이블의 주소 영역 내에서 고르게 분포되어야 함\n계산이 빨라야 함\n제산 함수: h(k) = k mod M (해시 테이블의 크기 M은 소수 선택)\n폴딩 함수: 키를 여러 부분으로 나누고, 이를 조합하는 방식으로 해시 주소 생성\n중간 제곱 함수: 탐색키를 제곱한 다음, 중간의 몇 비트를 취해서 해시 주소 생성\n비트 추출 함수: 키를 이진수로 간주, 임의의 위치에 k개의 비트를 사용\n숫자 분석 방법: 키에서 편중되지 않는 수들을 테이블의 크기에 적합하게 조합\n탐색키가 문자열인 경우\npython 1 2 3 4 5 6 def hashFn(key): sum = 0 # 문자열의 모든 문자에 대해 그 문자의 아스키 코드 값을 sum에 더함 for c in key: sum = sum + ord(c) return sum % M 탐색 방법들의 성능 비교 해싱의 적재 밀도(적재 비율)\nLoading Density\n저장되는 항목의 개수 n과 해시 테이블의 크기 M의 비율\nα = (저장된 항목의 개수) / (해싱 테이블의 버킷의 개수) = n / M\n탐색 방법 탐색 삽입 삭제 순차 탐색 O(n) O(1) O(n) 이진 탐색 O(log₂ n) O(n) O(n) 이진탐색트리 균형트리 O(log₂ n) O(log₂ n) O(log₂ n) 경사트리 O(n) O(n) O(n) 해싱 최선의 경우 O(1) O(1) O(1) 최악의 경우 O(n) O(n) O(n) 맵 응용 맵 ADT 구현 리스트를 이용해 순차 탐색 맵을 구현하는 방법\n리스트를 정렬해서 이진 탐색 맵을 구현하는 방법\n선형조사법으로 해시 맵을 구현하는 방법\n체이닝으로 해시 맵을 구현하는 방법\n엔트리 클래스 python 1 2 3 4 5 6 class Entry: def __init__(self, key, value): self.key = key self.value = value def _str_(self): return str(\u0026#34;%s:%s\u0026#34;%(self.key, self.value)) 리스트를 이용한 순차 탐색 맵 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SequentialMap: def __init__(self): self.table = [] def insert(self, key, value): self.table.append(Entry(key, value)) def search(self, key): pos = sequential_search(self.table, key, 0, self.size()-1) if pos is not None: return self.table[pos] else: return None def delete(self, key): for i in range(self.size()): if self.table[i].key == key: self.table.pop(i) return 파이썬의 딕셔너리를 이용한 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 d = {} d[\u0026#39;data\u0026#39;] = \u0026#39;자료\u0026#39; d[\u0026#39;structure\u0026#39;] = \u0026#39;구조\u0026#39; d[\u0026#39;sequential_search\u0026#39;] = \u0026#39;선형 탐색\u0026#39; d[\u0026#39;game\u0026#39;] = \u0026#39;게임\u0026#39; d[\u0026#39;binary_search\u0026#39;] = \u0026#39;이진 탐색\u0026#39; print(\u0026#34;나의 단어장:\u0026#34;) print(d) if d.get(\u0026#39;game\u0026#39;): print(\u0026#34;탐색:game --\u0026gt; \u0026#34;, d[\u0026#39;game\u0026#39;]) if d.get(\u0026#39;over\u0026#39;): print(\u0026#34;탐색:over --\u0026gt; \u0026#34;, d[\u0026#39;over\u0026#39;]) if d.get(\u0026#39;data\u0026#39;): print(\u0026#34;탐색:data --\u0026gt; \u0026#34;, d[\u0026#39;data\u0026#39;]) d.pop(\u0026#39;game\u0026#39;) print(\u0026#34;나의 단어장:\u0026#34;) print(d) bash 1 2 3 4 5 6 나의 단어장: {\u0026#39;data\u0026#39;: \u0026#39;자료\u0026#39;, \u0026#39;structure\u0026#39;: \u0026#39;구조\u0026#39;, \u0026#39;sequential_search\u0026#39;: \u0026#39;선형 탐색\u0026#39;, \u0026#39;game\u0026#39;: \u0026#39;게임\u0026#39;, \u0026#39;binary_search\u0026#39;: \u0026#39;이진 탐색\u0026#39;} 탐색:game --\u0026gt; 게임 탐색:data --\u0026gt; 자료 나의 단어장: {\u0026#39;data\u0026#39;: \u0026#39;자료\u0026#39;, \u0026#39;structure\u0026#39;: \u0026#39;구조\u0026#39;, \u0026#39;sequential_search\u0026#39;: \u0026#39;선형 탐색\u0026#39;, \u0026#39;binary_search\u0026#39;: \u0026#39;이진 탐색\u0026#39;} ","date":"2025-09-19T19:28:00+09:00","permalink":"https://kimcatchy.github.io/p/ds-search/","title":"탐색"},{"content":"주석 프로그램 중 실행하지 말라고 표시한 부분\n주석으로 표시되면 컴파일하기 전에 제거\n프로그램에 설명을 추가하거나 프로그램의 일부분을 잠시 실행하고 싶지 않을 때 사용\nc\u0026#43;\u0026#43; 1 2 3 4 5 // 한 문장을 주석 처리 /* 여러 문장을 주석 처리 할 때 사용 */ 매크로 프로그램의 수정이 용이\n상수들에 이름을 부여함으로써 프로그램의 이해를 도움\n매크로 속에 또 다른 매크로를 넣을 수 있음\n수식은 괄호로 감싸는 것이 좋음\n매크로 함수 Macro with arguments\n함수와 같은 형태를 가진 매크로들\n인자 자리에 있는 것들이 해당 매개변수 위치로 치환\nc\u0026#43;\u0026#43; 1 2 #define MAX(x,y) ((x)\u0026gt;(y) ? (x) : (y)) e = MAX(a+b,c+d); 일반 함수는 값이 대입이 일어나므로 자료형을 맞춰야 하지만 매크로 함수는 텍스트의 치환이므로 자료형과는 무관 매크로 함수 주의점 치환할 텍스트 안에 있는 모든 매개변수 주위와 치환 텍스트 전체를 괄호로 감싸야 함 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 #define MULT(x,y) x*y e = MULT(2+1,3+2); // 결과: e = 2+1*3+2 = 7 #define MULT(x,y) ((x)*(y)) e = MULT(2+1,3+2); // 결과: e = ((2+1)*(3+2)) = 15 겉보기와 다르게 동작할 수 있음 c\u0026#43;\u0026#43; 1 2 3 4 #define MAX(x,y) ((x)\u0026gt;(y) ? (x) : (y)) e = MAX(a++,b); // 매크로 함수의 수식에서 크기 비교를 위한 (x)\u0026gt;(y) 부분에서 a++로 한번 증가 // 그 뒤 (x) : (y) 부분도 a++로 치환되기 때문에 a가 한번 더 증가함 문자열 안은 매크로 치환 불가 매크로 함수가 필요한 경우 매크로 함수의 치환 텍스트에서 매개변수 앞에 #이 있으면, 해당 인자를 문자열로 변환하여 치환 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 ... printf(\u0026#34;a = %f\\\\n\u0026#34;, a); printf(\u0026#34;b = %f\\\\n\u0026#34;, b); printf(\u0026#34;c = %f\\\\n\u0026#34;, c); printf(\u0026#34;d = %f\\\\n\u0026#34;, d); printf(\u0026#34;e = %f\\\\n\u0026#34;, e); ... c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 #define PRINT(expr) printf(#expr \u0026#34; = %f\\\\n\u0026#34;, expr) // PRINT(a);를 하게 되면 #expr은 a가 아니라 \u0026#34;a\u0026#34;로 치환됨 // 따라서 PRINT(a);는 printf(\u0026#34;a\u0026#34; \u0026#34; = %f\\\\n\u0026#34;, a);가 됨 // 연속된 문자열은 연결된 것으로 취급, printf(\u0026#34;a = %f\\\\n\u0026#34;, a); ... PRINT(a); PRINT(b); PRINT(c); PRINT(d); PRINT(e); ... ##: 치환 텍스트에 사용될 경우, 인자와 다른 글자들을 붙여줌 c\u0026#43;\u0026#43; 1 2 3 #define VNAME(n) a##n VNAME(3) = 10; // a3 = 10; 이 됨 전처리 과정 #include 해당 파일을 가져와서 포함시킴\n#include \u0026lt;파일이름\u0026gt;: 해당 파일을 시스템에서 제공하는 헤더 파일들에서 찾음\n#include \u0026quot;파일이름\u0026quot;: 해당 파일을 사용자가 작성한 파일들에서 찾음\n조건부 컴파일 컴파일 과정에서 어느 부분을 포함시킬지 결정\n조건부 컴파일을 사용하는 이유\n같은 프로그램을 조금씩 기능을 다르게 하며 컴파일 할 때\n소프트웨어를 판매할 때, 간단한 기능만 되는 것과 모든 기능이 되는 것으로 두 가지 버전을 판매할 때\n#if, #endif, #elif, #else\n#if 다음의 조건식이 맞으면 #if와 #endif 사이의 문장들을 컴파일함\n조건식이 틀리면 #if와 #endif 사이의 문장들을 컴파일하지 않음\n#if의 조건식은 컴파일하기 전에 판단하기 때문에 조건식이 상수식이며 컴파일하기 전에 판단 가능해야함\n#if도 중첩이 가능하고 관계 연산자나 논리 연산자 사용 가능\ndefined\ndefined(매크로) 또는 defined 매크로로 사용\n해당 매크로가 정의되어 있으면 1, 그렇지 않으면 0\n매크로가 무엇으로 정의되어 있는지는 상관없음\n줄여서 #ifdef로 사용가능, #ifndef는 #if !defined와 동일\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 #define LEVEL ... #if defined(LEVEL) ... ... #endif ### 열거형 정수의 특정한 이름 부여\n각 정수의 이름들을 기호 상수라고 부름\n특정하게 약속한 정수값의 의미를 명확하게 드러내고 싶을 때 사용\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 enum days {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; enum days a, b; a = Tue; b = a+3; if(b == Fri) printf(\u0026#34;It\u0026#39;s Friday!\u0026#34;); 유도 자료형 기본 자료형: int, char와 같이 문법적으로 주어지는 자료형\n유도 자료형: 구조체와 같이 다른 자료형을 이용해서 만드는 자료형\n구조체, 공용체, 비트필드\n공용체 Union\n구조체와 거의 유사하지만 멤버들이 같은 메모리 공간을 공유함\n공간을 공유하므로 다른 멤버에 값을 저장하면 기존 멤버의 값은 사라짐\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 union val { int i; double f; }; union val a; a.i = 3; a.f = 2.0; // a.f 값 저장 시 a.i의 값이 사라짐 비트 필드 구조체와 거의 유사\n멤버들이 비트 단위의 크기를 가지는 정수형\n멤버들의 자료형은 unsigned 혹은 signed int형만 가능\n일반적인 구조체처럼 사용\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 struct bits { unsigned int a: 3; signed int b: 5; unsigned int : 2; unsigned int : 0; unsigned int c: 4; }; ","date":"2025-09-19T19:22:00+09:00","permalink":"https://kimcatchy.github.io/p/preprocesing-and-derived-data-type/","title":"전처리 \u0026 유도 자료형"},{"content":"정렬 데이터를 순서대로 재배열하는 것\n가장 기본적이고 중요한 알고리즘\n비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있음\n오름차순(ascending)과 내림차순(descending)\n정렬 알고리즘의 종류 정렬 장소에 따른 분류\n내부 정렬: 모든 데이터가 메인 메모리\n외부 정렬: 외부 기억 장치에 대부분의 레코드\n단순하지만 비효율적인 방법\n삽입, 선택, 버블 정렬 등 복잡하지만 효율적인 방법\n퀵, 합, 병합, 기수정렬, 팀 등 선택 정렬 Selection Sort\n여러 데이터 중에서 가장 작은 값을 뽑는 작동을 반복하여 값을 정렬\n최솟값을 찾는 방법 첫 번째 값을 현재 가장 작은 값으로 지정\n지정한 값을 다음 차례의 값과 비교하여 더 작은 값을 현재 가장 작은 값으로 변경하거나 유지\n마지막 값까지 비교를 마친 후 현재 가장 작은 값으로 지정된 값을 가장 작은 값으로 결정\n두 변수 값 교환 두 변수 값을 교환해야 하는 경우 임시 공간을 사용해야 함\ntemp = A, A = B, B = temp\nA, B = B, A\n선택 정렬 구현 오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트의 맨 뒤로 이동하는 작업을 반복\n시간 복잡도: (n-1) + (n-2) + \u0026hellip; + 1 = n(n-1)/2 = O(n²)\n알고리즘이 간단, 자료 이동 횟수가 미리 결정\n정렬 된 리스트 정렬 안 된 리스트 설명 [] [5, 3, 8, 4, 9, 1, 6, 2, 7] 초기 상태 [1] [5, 3, 8, 4, 9, 6, 2, 7] 1 선택 및 이동 [1, 2] [5, 3, 8, 4, 9, 6, 7] 2 선택 및 이동 [1, 2, 3] [5, 8, 4, 9, 6, 7] 3 선택 및 이동 \u0026hellip; \u0026hellip; 4~8 선택 및 이동 [1, 2, 3, 4, 5, 6, 7, 8, 9] [] 9 선택 및 이동 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def selection_sort(A): n = len(A) for i in range(n-1): least = i; for j in range(i+1, n): if (A[j] \u0026lt; A[least]): least = j A[i], A[least] = A[least], A[i] printStep(A, i+1) def printStep(arr, val): print(\u0026#34; Step %2d = \u0026#34; % val, end =\u0026#39;\u0026#39;) print(arr) data = [5, 3, 8, 4, 9, 1, 6, 2, 7] print(\u0026#34;Original :\u0026#34;, data) selection_sort(data) print(\u0026#34;Selection :\u0026#34;, data) python 1 2 3 4 5 6 7 8 9 10 Original : [5, 3, 8, 4, 9, 1, 6, 2, 7] Step 1 = [1, 3, 8, 4, 9, 5, 6, 2, 7] Step 2 = [1, 2, 8, 4, 9, 5, 6, 3, 7] Step 3 = [1, 2, 3, 4, 9, 5, 6, 8, 7] Step 4 = [1, 2, 3, 4, 9, 5, 6, 8, 7] Step 5 = [1, 2, 3, 4, 5, 9, 6, 8, 7] Step 6 = [1, 2, 3, 4, 5, 6, 9, 8, 7] Step 7 = [1, 2, 3, 4, 5, 6, 7, 8, 9] Step 8 = [1, 2, 3, 4, 5, 6, 7, 8, 9] Selection : [1, 2, 3, 4, 5, 6, 7, 8, 9] 삽입 정렬 Insertion Sort\n정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정 반복\n삽입 위치를 찾는 방법 빈 배열일 때는 첫 번째 자리에 삽입함\n현재 정렬된 데이터 그룹의 가장 큰 값과 위치를 정할 새 데이터의 값을 비교\n새 데이터 값이 크면 맨 뒤에 삽입, 그렇지 않으면 정렬된 데이터 그룹에서 한 칸씩 앞으로 이동하며 새 데이터 값보다 작은 값을 만나면 작은 값 뒤에 삽입\n삽입 정렬 구현 시간 복잡도(최선): O(n)\n이미 정렬되어 있는 경우\n비교 (n-1)\n시간 복잡도(최악): O(n²)\n역순으로 정렬되어 있는 경우\n모든 단계에서 앞의 자료 전부 이동\n비교 (n(n-1))/2 = O(n²)\n이동 (n(n-1))/2 + 2(n-1) = O(n²)\n많은 이동이 필요하면 레코드가 큰 경우 불리함\n대부분 정렬되어 있으면 매우 효율적\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def insertion_sort(A): n = len(A) for i in range(1, n): key = A[i] j = i-1 while j\u0026gt;=0 and A[j]\u0026gt;key: A[j+1] = A[j] j -= 1 A[j+1] = key printStep(A, i) def printStep(arr, val): print(\u0026#34; Step %2d = \u0026#34; % val, end =\u0026#39;\u0026#39;) print(arr) data = [5, 3, 8, 4, 9, 1, 6, 2, 7] print(\u0026#34;Original :\u0026#34;, data) insertion_sort(data) print(\u0026#34;Selection :\u0026#34;, data) python 1 2 3 4 5 6 7 8 9 10 Original : [5, 3, 8, 4, 9, 1, 6, 2, 7] # 초기 상태 Step 1 = [3, 5, 8, 4, 9, 1, 6, 2, 7] # 3을 삽입 Step 2 = [3, 5, 8, 4, 9, 1, 6, 2, 7] # 8은 이미 제자리 Step 3 = [3, 4, 5, 8, 9, 1, 6, 2, 7] # 4를 3과 5 사이에 삽입 Step 4 = [3, 4, 5, 8, 9, 1, 6, 2, 7] # 9는 이미 제자리 Step 5 = [1, 3, 4, 5, 8, 9, 6, 2, 7] # 1을 3 앞에 삽입 Step 6 = [1, 3, 4, 5, 6, 8, 9, 2, 7] # 6을 5와 8 사이에 삽입 Step 7 = [1, 2, 3, 4, 5, 6, 8, 9, 7] # 2를 1과 3 사이에 삽입 Step 8 = [1, 2, 3, 4, 5, 6, 7, 8, 9] # 7을 6과 8 사이에 삽입 Selection : [1, 2, 3, 4, 5, 6, 7, 8, 9] # 최종 정렬 결과 버블 정렬 Bubble Sort\n인접한 2개의 레코드를 비교하여 순서대로 서로 교환\n비교-교환 과정을 리스트의 전체에 수행(스캔)\n한번의 스캔이 완료되면 리스트의 오른쪽 끝에 가장 큰 레코드\n끝으로 이동한 레코드를 제외하고 다시 스캔 반복\n버블 정렬 구현 시간 복잡도: O(n²)\n비교 (n(n-1))/2 = O(n²)\n이동(평균) = O(n²)\n역순으로 정렬된 경우(최악): n²\n이미 정렬된 경우(최선): 0\n레코드의 이동 과다: 이동연산은 비교연산보다 더 많은 시간이 소요\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def bubble_sort(A): n = len(A) for i in range(n-1, 0, -1): bChanged = False for j in range(i): if (A[j]\u0026gt;A[j+1]): A[j], A[j+1] = A[j+1], A[j] bChanged = True if not bChanged: break printStep(A, n-i) def printStep(arr, val): print(\u0026#34; Step %2d = \u0026#34; % val, end =\u0026#39;\u0026#39;) print(arr) data = [5, 3, 8, 4, 9, 1, 6, 2, 7] print(\u0026#34;Original :\u0026#34;, data) bubble_sort(data) print(\u0026#34;Selection :\u0026#34;, data) python 1 2 3 4 5 6 7 8 Original : [5, 3, 8, 4, 9, 1, 6, 2, 7] Step 1 = [3, 5, 4, 8, 1, 6, 2, 7, 9] Step 2 = [3, 4, 5, 1, 6, 2, 7, 8, 9] Step 3 = [3, 4, 1, 5, 2, 6, 7, 8, 9] Step 4 = [3, 1, 4, 2, 5, 6, 7, 8, 9] Step 5 = [1, 3, 2, 4, 5, 6, 7, 8, 9] Step 6 = [1, 2, 3, 4, 5, 6, 7, 8, 9] Selection : [1, 2, 3, 4, 5, 6, 7, 8, 9] 집합의 연산 집합의 원소들을 항상 정렬된 순으로 저장\n삽입 연산은 더 복잡해짐\n집합의 비교나 합집합, 차집합, 교집합 → 효율적 구현 가능\n삽입 연산 삽입할 위치를 먼저 찾아야 함 python 1 2 3 4 5 6 7 8 # 정렬된 상태를 유지하면서 elem 삽입 def insert(self, elem): if elem in self. items: return # 이미 있으면 return for idx in range(len(self.items)): # loop n번 if elem \u0026lt; self.items[idx]: # 삽입할 위치 idx self.items.insert(idx, elem) return self.items.append(elem) # 맨 뒤에 삽입 비교 연산 두 집합의 원소의 개수가 같아야 같은 집합이 됨\n집합이 정렬되어 있으므로 순서대로 같은 원소를 가져야 함\n시간 복잡도: O(n²) → O(n)으로 개선\npython 1 2 3 4 5 6 7 def __eq__(self, setB): if self.size() != setB.size(): return False for idx in range(len(self.items)): if self.items[idx] != setB.items[idx]: return False return True 합집합 / 교집합 / 차집합 합집합 연산 방법\n가장 작은 원소들로부터 비교하여 더 작은 원소를 새로운 집합에 넣고 그 집합의 인덱스를 증가시킴\n만약 두 집합의 현재 원소가 같으면 하나만을 넣음 (인덱스는 모두 증가시킴)\n한쪽 집합이 모두 처리되면 나머지 집합의 남은 모든 원소를 순서대로 새 집합에 넣음\n시간 복잡도: O(n²) → O(n)으로 개선\n교집합과 차집합도 동일한 방법 적용 가능\n개선된 합집합 알고리즘 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def union(self, setB): newSet = Set() a = 0 b = 0 while a \u0026lt; len(self.items) and b \u0026lt; len(SetB.items): valueA = self.items[a] valueB = SetB.items[b] if valueA \u0026lt; valueB: newSet.items.append(valueA) a+= 1 elif valueA \u0026gt; valueB: newSet.items.append(valueA) b += 1 else: newSet.items.append(valueA) a += 1 b += 1 while a \u0026lt; len(self.items): newSet.items.append(self.items[a]) a += 1 while b \u0026lt; len(SetB.items): newSet.items.append(SetB.items[b]) b += 1 return newSet 집합의 연산 복잡도 비교 집합의 연산 정렬되지 않은 리스트 정렬된 리스트 insert(e) O(n) O(n) eq(SetB) O(n²) O(n) union(SetB) O(n²) O(n) intersect(SetB) O(n²) O(n) difference(SetB) O(n²) O(n) ","date":"2025-09-19T19:16:00+09:00","permalink":"https://kimcatchy.github.io/p/ds-sort-algorithm/","title":"선택/삽입/버블 정렬"},{"content":"구조체 여러 종류의 변수를 모아서 한 번에 만들 수 있도록 한 것\n배열과의 차이: 배열은 같은 종류의 변수를 여러 개 만들 때 사용\n예시 1: 평면 위의 점을 x, y 좌표로 표현 c\u0026#43;\u0026#43; 1 2 3 // 구조체를 사용하지 않았을 때 float a_x, a_y; float b_x, b_y; c\u0026#43;\u0026#43; 1 2 3 4 5 // 구조체를 사용했을 때 struct point { float x; float y; } a, b; 구조체를 사용하지 않으면 a_x와 a_y 등의 관계가 불명확함\n구성 요소가 많을수록 구조체가 유리해짐\npoint는 구조체 태그, 구조체 태그가 선언되면 이후에 그 태그로 변수 생성 가능\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct point { float x; float y; } a, b; // 구조체 변수 안의 멤버에 접근 a.x = 3.0; b.y = a.x * 2; // 배열처럼 초기화 가능 struct point a = {2.0, 3.0}; // 구조체 변수끼리 대입 struct point a = {2.0, 3.0}, b; b = a; 예시 2: 두 점의 좌표를 입력 받아서 두 점 사이의 거리 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct point { float x, y; }; struct point a, b; float d; scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;a.x); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;a.y); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;b.x); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;b.y); d = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y); d = sqrt(d); printf(\u0026#34;%f\\\\n\u0026#34;, d); struct point는 구조체의 틀만 선언하는 것이고 실제로 공간이 할당되는 것은 아님\n실제 공간 할당은 변수를 만들 때 할당\n구조체 배열 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 struct point { float x, y; }; struct point b[5]; b[2].x = 1.0; b[3].y = b[2].x * 3; 구조체 포인터 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 struct point { float x, y; }; struct point a; struct point *c; c = \u0026amp;a; (*c).x = 7.0; (*c).y = (*c).x + 2; // (*c).x 는 c-\u0026gt;x 와 같이 사용할 수 있음 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main() { struct point { float x, y; }; struct point b[5]; struct point *c; c = b; c[1].x = 2.0; (c+2)-\u0026gt;y = (*(c+1)).x + (b+1)-\u0026gt;x; for (int i=0; i\u0026lt;5; i++) { printf(\u0026#34;%f \u0026#34;, b[i].x); printf(\u0026#34;%f\\\\n\u0026#34;, b[i].y); }; } // 출력 결과: b[1].x = 2.0, b[2].y = 4.0 구조체 관련 문법 구조체 멤버로 가능한 것들: 변수, 배열, 포인터, 다른 구조체 변수\n자기 참조 구조체: 구조체 멤버로 자신을 포함하는 경우\n자기 자신(구조체)를 넣을 경우 무한히 큰 공간을 차지하므로 불가능\n자기 자신의 포인터는 가능\ntypedef: 사용자가 새로운 자료형 이름을 만들어 사용할 수 있게 함\nc\u0026#43;\u0026#43; 1 2 3 4 5 typedef struct point { float x, y; } t_point; ... t_point a, b; 구조체와 함수 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; struct point { float x, y; }; float dist(struct point a, struct point b) { float d; d = (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y); d = sqrt(d); return d; } int main(void) { struct point e, f; float d; scanf(\u0026#34;%f\u0026#34;, \u0026amp;e.x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;e.y); scanf(\u0026#34;%f\u0026#34;, \u0026amp;f.x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;f.y); d = dist(e, f); printf(\u0026#34;%f\\\\n\u0026#34;, d); } 함수의 매개변수로 구조체형이 올 수 있음\n인자가 매개변수로 복사됨\n값에 의한 호출\n각각의 멤버들이 그대로 복사됨\n멤버가 많을 경우 비효율적이 될 수 있음 → 구조체 포인터를 주로 이용\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; struct point { float x, y; }; float dist(struct point *a, struct point *b) { float d; d = (a-\u0026gt;x - b-\u0026gt;x)*(a-\u0026gt;x - b-\u0026gt;x) + (a-\u0026gt;y - b-\u0026gt;y)*(a-\u0026gt;y - b-\u0026gt;y); d = sqrt(d); return d; } int main(void) { struct point e, f; float d; scanf(\u0026#34;%f\u0026#34;, \u0026amp;e.x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;e.y); scanf(\u0026#34;%f\u0026#34;, \u0026amp;f.x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;f.y); d = dist(\u0026amp;e, \u0026amp;f); printf(\u0026#34;%f\\\\n\u0026#34;, d); } ","date":"2025-09-19T19:10:00+09:00","permalink":"https://kimcatchy.github.io/p/c-struct/","title":"구조체"},{"content":"[object Promise]## 알고리즘의 기본 원리\n시작 정점을 선택하고 해당 정점까지의 거리를 0으로 초기화\n나머지 모든 정점까지의 거리를 무한대로 초기화\n방문하지 않은 정점 중 최단 거리인 정점을 선택\n선택한 정점의 인접 정점들에 대해, 현재까지의 최단 거리를 갱신\n모든 정점을 방문할 때까지 3-4 단계를 반복\n알고리즘의 동작 과정 초기화: 시작 정점의 거리를 0으로, 나머지 정점들의 거리를 무한대로 설정\n정점 선택: 방문하지 않은 정점 중 최단 거리인 정점을 선택\n거리 갱신: 선택한 정점의 인접 정점들에 대해, 현재 알려진 거리와 선택한 정점을 경유하는 거리를 비교하여 더 짧은 거리로 갱신\n반복: 모든 정점을 방문할 때까지 2-3 단계를 반복\n구현 방법 배열을 이용한 구현\n시간 복잡도: O(V²), V는 정점의 수\n간단하지만 큰 그래프에서는 비효율적\n우선순위 큐를 이용한 구현\n시간 복잡도: O((V+E)logV), E는 간선의 수\n더 효율적이며, 대규모 그래프에 적합\n코드 예시 heapq 모듈을 사용하여 우선순위 큐 관리 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import heapq def dijkstra(graph, start): distances = {vertex: float(\u0026#39;infinity\u0026#39;) for vertex in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance \u0026gt; distances[current_vertex]: continue for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight if distance \u0026lt; distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # 사용 예시 graph = { \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 1, \u0026#39;C\u0026#39;: 4}, \u0026#39;B\u0026#39;: {\u0026#39;A\u0026#39;: 1, \u0026#39;C\u0026#39;: 2, \u0026#39;D\u0026#39;: 5}, \u0026#39;C\u0026#39;: {\u0026#39;A\u0026#39;: 4, \u0026#39;B\u0026#39;: 2, \u0026#39;D\u0026#39;: 1}, \u0026#39;D\u0026#39;: {\u0026#39;B\u0026#39;: 5, \u0026#39;C\u0026#39;: 1} } result = dijkstra(graph, \u0026#39;A\u0026#39;) print(result) 알고리즘의 특징 양의 가중치: 다익스트라 알고리즘은 음의 가중치를 가진 간선이 없는 그래프에서만 정확히 작동\n그리디 접근: 매 단계에서 가장 가까운 정점을 선택하는 그리디(greedy) 방식을 사용\n최적 부분 구조: 최단 경로의 부분 경로 역시 최단 경로\n응용 분야 네트워크 라우팅: 데이터 패킷의 최적 경로 결정\nGPS 내비게이션: 최단 경로 찾기\n로봇 경로 계획: 장애물을 피해 목적지까지의 최적 경로 계산\n소셜 네트워크 분석: 사용자 간 최단 연결 경로 찾기\n한계점 음의 가중치를 가진 간선이 있는 그래프에서는 사용할 수 없음\n모든 정점 쌍 간의 최단 경로를 구하는 데는 비효율적일 수 있음\n","date":"2025-09-19T19:08:00+09:00","permalink":"https://kimcatchy.github.io/p/dijkstra-algorithm/","title":"Dijkstra's Algorithm"},{"content":"연결된 구조 흩어진 데이터를 링크로 연결해서 관리 배열 구조의 리스트 연결된 구조의 리스트 모든 노드들을 연속된 메모리 공간에 저장 노드들이 물리적으로 떨어진 곳에 위치 확보된 공간을 넘어서 새로운 노드를 저장할 수 없음 각 노드의 번지도 순차적이지 않음 화살표로 표시된 연결을 따라가면 선형 리스트 순서와 같음 용량이 고정되지 않음 배열 구조의 리스트 연결된 구조의 리스트 할당된 메모리 공간을 사용하지 않으면 메모리 낭비 필요한 만큼 메모리 할당, 크기의 제한도 없음 - 효율성 할당된 메모리 공간을 넘어서는 새로운 항목 삽입 불가 중간에 자료를 삽입하거나 삭제하는 것이 용이 배열 구조의 리스트 연결된 구조의 리스트 항목 삽입/삭제 시 뒤의 모든 항목들을 이동 항목 삽입/삭제 시 연결(Link)만 수정 연결 리스트의 구조 노드(Node) 데이터 필드: 저장하고 싶은 데이터 (정수, 실수, 문자열, 클래스, 다른 리스트 등)\n하나 이상의 링크 필드: 다른 노드의 주소를 저장하는 변수\n헤드 포인터(Head Pointer) 연결 리스트는 첫 번째 노드만 알면 링크로 연결된 모든 노드에 순차적 접근 가능\n시작 노드의 주소를 반드시 저장해야 함 첫 번째 노드의 주소를 저장하는 변수를 헤드 포인터라고 함\n마지막 노드는 더 이상 연결할 노드가 없음\n링크의 값을 None으로 설정하여 이 노드가 마지막임을 표시 연결 리스트의 종류 단순 연결 리스트 Singly Linked List\n하나의 방향으로 연결되어 있는 구조이므로 링크는 하나\n링크에는 다음 노드의 주소를 기억\n마지막 노드는 아무것도 연결되어 있지 않다는 의미로 None 값을 가짐\n스택과 리스트를 단순 연결 리스트로 구현 가능\n원형 연결 리스트 Circular Linked List\n단순 연결 리스트와 동일한 노드 구조를 사용하지만 맨 마지막 노드의 링크 값이 None이 아니라 다시 첫 번째 노드를 가리킴\n노드를 순서대로 방문할 때 종료 조건에 유의해야 함\n이중 연결 리스트 Doubly Linked List\n하나의 노드가 이전 노드와 다음 노드를 모두 알 수 있도록 설계\n두 개의 링크를 갖는데, 하나는 선행 노드를, 다른 하나는 후속 노드를 가리킴\n단순 연결 리스트로 구현한 리스트 스택: 노드 클래스 python 1 2 3 4 class Node: def __init__(self, elem, link=None): self.data = elem self.link = link 스택: 연결된 스택 클래스 python 1 2 3 4 5 6 class LinkedStack: def __init__(self): self.top = None def isEmpty(self): return self.top == None def clear(self): self.top = None 스택: 삽입 입력 데이터 E를 이용해 새로운 노드 n을 생성 (n = Node(E))\nn의 링크가 시작 노드를 가리키도록 함 (n.link = top)\ntop이 n을 가리키도록 함 (top = n)\npython 1 2 3 def push(self, item): n = Node(item, self.top) self.top = n 스택: 삭제 변수 n이 시작 노드를 가리키도록 함 (n = top)\ntop이 다음 노드를 가리키도록 함 (top = n.link)\nn이 가리키는 노드의 데이터를 반환 (return n.data)\npython 1 2 3 4 5 def pop(self): if not self.isEmpty(): n = self.top self.top = self.n.link return n.data 스택: 전체 노드의 방문 python 1 2 3 4 5 6 7 def size(self): node = self.top count = 0 while not node == None: node = node.link count +=1 return count 연결 리스트 노드 클래스: 연결된 스택에서와 동일\n스택에서의 self.top을 self.head로 수정\n연결 리스트 클래스\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head == None def clear(self): self.head = None def size(self): node = self.head count = 0 while not node == None: node = node.link count +=1 return count def display(self, msg): ... pos번째 노드 반환: getNode(pos) python 1 2 3 4 5 6 7 def getNode(self, pos): if pos \u0026lt; 0: return None node = self.head while pos \u0026gt; 0 and node != None: node = node.link pos -= 1 return node getEntry(pos), replace(pos, elem), find(val) python 1 2 3 4 5 6 7 8 def getEntry(self, pos): node = self. getNode(pos) if node == None: return None else: return node.data def replace(self, pos, elem): node = self.getNode(pos) if node is not None: node.data = elem 삽입 연산: insert(pos, elem)\n삽입할 노드가 삽입할 위치 다음의 노드를 향하게 함 (node.link = before.link)\n삽입할 위치 전의 노드가 삽입할 노드를 향하게 함 (before.link = node)\npython 1 2 3 4 5 6 7 def insert(self, pos, elem): before = self.getNode(pos-1) if before == None: self.head = Node(elem, self.head) else: node = Node(elem, before.link) before.link = node 삭제: before의 link가 삭제할 노드의 다음 노드를 가리키도록 함 (before.link = before.link.link) plain 1 2 3 4 5 6 def delete(self, pos): before = self.getNode(pos-1) if before == None: self.head = self.head.link elif before.link != None: before.link = before.link.link 테스트 코드 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Node: def __init__(self, elem, link=None): self.data = elem self.link = link class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head == None def clear(self): self.head = None def size(self): node = self.head count = 0 while node is not None: node = node.link count += 1 return count def display(self, msg): print(msg) node = self.head while node is not None: print(node.data, end=\u0026#39; \u0026#39;) node = node.link print() # 줄바꿈 def getNode(self, pos): if pos \u0026lt; 0: return None node = self.head while pos \u0026gt; 0 and node is not None: node = node.link pos -= 1 return node def getEntry(self, pos): node = self.getNode(pos) if node is None: return None return node.data def insert(self, pos, elem): if pos \u0026lt; 0: return # 잘못된 위치 처리 before = self.getNode(pos - 1) if before is None: # head에 삽입 self.head = Node(elem, self.head) else: # Insert after the node node = Node(elem, before.link) before.link = node def delete(self, pos): if pos \u0026lt; 0: return # 잘못된 위치 처리 before = self.getNode(pos - 1) if before is None: self.head = self.head.link elif before.link is not None: before.link = before.link.link def replace(self, pos, elem): node = self.getNode(pos) if node is not None: node.data = elem s = LinkedList() s.display(\u0026#39;단순연결리스트로 구현한 리스트(초기상태):\u0026#39;) s.insert(0, 10); s.insert(0, 20); s.insert(1, 30); s.insert(s.size(), 40); s.insert(2, 50) s.display(\u0026#39;단순연결리스트로 구현한 리스트(삽입*5):\u0026#39;) s.replace(2, 90) s.display(\u0026#39;단순연결리스트로 구현한 리스트(교체*1):\u0026#39;) s.delete(2); s.delete(s.size()-1); s.delete(0) s.display(\u0026#39;단순연결리스트로 구현한 리스트(삭제*3):\u0026#39;) s.clear() s.display(\u0026#39;단순연결리스트로 구현한 리스트(초기화):\u0026#39;) 원형 연결 리스트로 구현한 큐 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Node: def __init__(self, elem, link=None): self.data = elem self.link = link class CircularLinkedQueue: def __init__(self): # 생성자 함수 self.tail = None # tail: 유일한 데이터 def isEmpty(self): return self.tail == None # 공백 상태 검사 def clear(self): self.tail = None # 큐 초기화 def peek(self): # peek 연산 if not self.isEmpty(): # 공백이 아니면 return self.tail.link.data # front의 data 반환 # 삽입 연산: 큐가 공백상태인 경우 삽입 def enqueue(self, item): node = Node(item, None) if self.isEmpty(): node.link = node self.tail = node # 공백상태가 아닌 경우 else: node.link = self.tail.link self.tail.link = node self.tail = node # 삭제 연산: 큐가 하나의 항목을 갖는 경우 def dequeue(self): if not self.isEmpty(): data = self.tail.link.data if self.tail.link == self.tail: self.tail = None # 큐가 여러 개의 항목을 갖는 경우 else: self.tail.link = self.tail.link.link return data #전체 노드의 방문 def size(self): if self.isEmpty(): return 0 # 공백이면 0 반환 else: count = 1 # 카운트 최소 1 node = self.tail.link # node는 front부터 출발 while not node == self.tail: node = node.link # node가 rear가 아닌 동안 count += 1 # 이동 후 count 증가 return count # 최종 count 반환 def display(self, msg=\u0026#39;CircularLinkedQueue\u0026#39;): print(msg, end=\u0026#39;\u0026#39;) print() if not self.isEmpty(): node = self.tail.link while not node == self.tail: print(node.data, end=\u0026#39; \u0026#39;) node = node.link print(node.data, end=\u0026#39; \u0026#39;) print() # 테스트 프로그램 q = CircularLinkedQueue() for i in range(8): q.enqueue(i) q.display() for i in range(5): q.dequeue() q.display() for i in range(8,14): q.enqueue(i) q.display() 이중 연결 리스트로 구현한 덱 단순 연결 리스트로 구현 시 문제점\n전단과 후단을 각각 front와 rear가 가리키고 양쪽에서 모두 삽입과 삭제가 가능한 구조\ndeleteRear 연산에서 후단을 삭제하고 나면 rear가 한칸 앞으로 움직여야 함\n단순 연결 리스트의 노드에는 선행 노드의 정보가 없으므로 front부터 시작해서 선행 노드를 탐색해야 함\n이중 연결 리스트로 구현 시 모든 노드가 선행과 후속 노드를 알고 있으므로 deleteRear도 O(1)\n덱이나 리스트와 같은 선형 자료 구조의 연산들을 가장 효율적으로 구현할 수 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 # 이중 연결 리스트의 노드는 각각 prev, next class DNode: def __init__(self, elem, prev=None, next=None): self.data = elem self.prev = prev self.next = next class DoublyLinkedDeque: def __init__(self): self.front = None self.rear = None def isEmpty(self): return self.front == None # 공백 상태 검사 def clear(self): self.front = self.front = None # 초기화 # self.top을 self.front로 변경경 def size(self): node = self.front count = 0 while not node == None: node = node.next count += 1 return count def display(self, msg=\u0026#39;LinkedDeque\u0026#39;): print(msg, end=\u0026#39;\u0026#39;) print() node = self.front while not node == None: print(node.data, end=\u0026#39; \u0026#39;) node = node.next print() # 전단 삽입 # 1. 노드 생성 및 prev, next 초기화 # 2. front가 선행노드 n을 가리킴 # 3. 그 뒤 front가 n을 가리킴 def addFront(self, item): node = DNode(item, None, self.front) if (self.isEmpty()): self.front = self.rear = node else: self.front.prev = node self.front = node # 후단 삽입 # 1. n의 next가 None, prev는 현재의 후단인 rear # 2. 다음으로 rear가 새로운 노드를 가리킴 # 3. 전후단 삽입의 시간 복잡도는 모두 O(1) def addRear(self, item): node = DNode(item, self.rear, None) if (self.isEmpty()): self.front = self.rear = node else: self.rear.next = node self.rear = node # 전후단 삭제 # 1. 삭제할 노드(front)의 데이터 복사 # 2. front를 다음으로 옮김 # 3. front의 이전 노드는 None def deleteFront(self): if not self.isEmpty(): data = self.front.data self.front = self.front.next # 노드가 하나뿐이면 rear도 None으로 설정해야 됨 if self.front == None: self.rear = None else: self.front.prev = None return data # 후단 삭제 deleteRear도 비슷하게 처리 def deleteRear(self): if not self.isEmpty(): data = self.rear.data self.rear = self.rear.prev if self.rear == None: self.front = None else: self.rear.next = None return data # 테스트 프로그램 dq = DoublyLinkedDeque() for i in range(9): if i%2 == 0: dq.addRear(i) else: dq.addFront(i) dq.display() for i in range(2): dq.deleteFront() dq.display() for i in range(3): dq.deleteRear() dq.display() for i in range(9,14): dq.addFront(i) dq.display() ","date":"2025-09-19T19:02:00+09:00","permalink":"https://kimcatchy.github.io/p/linked-list/","title":"Linked List"},{"content":"문제 [object Promise]### 제한사항\n공백도 하나의 문자로 취급합니다.\n1 ≤ message의 길이 ≤ 50\n편지지의 여백은 생각하지 않습니다.\nmessage는 영문 알파벳 대소문자, ‘!’, ‘~’ 또는 공백으로만 이루어져 있습니다.\n풀이 c\u0026#43;\u0026#43; 1 2 3 4 5 int solution(const char* message) { int answer = 0; while (message[answer] != \u0026#39;\\\\0\u0026#39;) answer++; return answer*2; } char* message는 문자열인 message의 첫 번째 주소\n마지막 주소는 null(\\0)\n문자열의 첫 주소부터 while문이 시작해서 null이 나오기 전까지 answer++\nc\u0026#43;\u0026#43; 1 2 3 4 #include \u0026lt;string.h\u0026gt; int solution(const char* message) { return strlen(message)*2; } string.h 헤더 파일 사용\nstrlen 함수로 문자열의 길이를 구한 후 값의 2배 return\n","date":"2025-09-19T18:50:00+09:00","permalink":"https://kimcatchy.github.io/p/length-of-string/","title":"문자열의 길이"},{"content":"문제 Write a function createCounter. It should accept an initial integer init. It should return an object with three functions.\nThe three functions are:\nincrement() increases the current value by 1 and then returns it.\ndecrement() reduces the current value by 1 and then returns it.\nreset() sets the current value to init and then returns it.\n출력 예시 Example 1: [object Promise] Output: \\[6,5,4\\]Explanation: const counter = createCounter(5); counter.increment(); // 6 counter.reset(); // 5 counter.decrement(); // 4 Example 2: [object Promise] Output: \\[1,2,1,0,0\\]Explanation: const counter = createCounter(0); counter.increment(); // 1 counter.increment(); // 2 counter.decrement(); // 1 counter.reset(); // 0 counter.reset(); // 0 풀이 javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @param {integer} init * @return { increment: Function, decrement: Function, reset: Function } */ var createCounter = function(init) { let i = init return { increment: function() { return ++i }, decrement: function() { return --i }, reset: function() { return i = init } } }; return하기 전에 값이 증가 → 전위연산자 사용 ","date":"2025-09-19T18:48:00+09:00","permalink":"https://kimcatchy.github.io/p/counter-2/","title":"Counter II"},{"content":"문제 [object Promise]### 제한사항\n0 \u0026lt; array의 길이 \u0026lt; 100\n0 ≤ array의 원소 \u0026lt; 1000\n풀이 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdlib.h\u0026gt; int solution(int array[], size_t array_len) { if (array_len == 1) return array[0]; int count[1000] = {0}; // 빈도를 저장할 배열 생성 int max_freq = 0; int mode = -1; int mode_count = 0; // 빈도 기록 for (int i = 0; i \u0026lt; array_len; i++) { count[array[i]]++; if (count[array[i]] \u0026gt; max_freq) { max_freq = count[array[i]]; } } // 최빈수와 최빈수의 빈도 확인 for (int i = 0; i \u0026lt; 1000; i++) { if (count[i] == max_freq) { mode = i; mode_count++; if (mode_count \u0026gt; 1) { return -1; } } } return mode; } 배열의 원소가 하나라면 해당 원소의 값 return\n제한사항에서 배열의 원소가 1000 미만이므로 빈도를 저장할 배열의 길이를 1000으로 했음\n다른 사람들의 풀이 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdlib.h\u0026gt; int solution(int array[], size_t array_len) { int answer = 0; int count = 0; int check = 0; for(int i = 0; i \u0026lt; array_len; i++){ for(int j = i; j \u0026lt; array_len; j++){ if (array[i] == array[j]) count++; } if(count \u0026gt; check){ answer = array[i]; check = count; } else if(count == check){ answer = -1; } count = 0; } return answer; } 배열에서 이후의 요소에 같은 값이 존재하면 count 증가\n해당 요소의 count가 check(이전에 확인한 최빈값의 빈도)보다 크면 answer에 값을 저장 후 check에 count 저장\ncount와 check의 값이 같다면 answer에 -1 저장\n","date":"2025-09-19T18:45:00+09:00","permalink":"https://kimcatchy.github.io/p/mode-of-an-array/","title":"배열의 최빈값 구하기"},{"content":"문제 Write a function expect that helps developers test their code. It should take in any value val and return an object with the following two functions.\ntoBe(val) accepts another value and returns true if the two values === each other. If they are not equal, it should throw an error \u0026ldquo;Not Equal\u0026rdquo;.\nnotToBe(val) accepts another value and returns true if the two values !== each other. If they are equal, it should throw an error \u0026ldquo;Equal\u0026rdquo;.\n출력 예시 Example 1: [object Promise] Output: {\u0026ldquo;value\u0026rdquo;: true}\n**Explanation**: 5 === 5 so this expression returns true. Example 2: [object Promise] Output: {\u0026ldquo;error\u0026rdquo;: \u0026ldquo;Not Equal\u0026rdquo;}\n**Explanation**: 5 !== null so this expression throw the error \u0026quot;Not Equal\u0026quot;. Example 3: [object Promise] Output: {\u0026ldquo;value\u0026rdquo;: true}\n**Explanation**: 5 !== null so this expression returns true. 필요 사전 지식 사실 object를 직접 생성해서 써본 적은 없었는데.. 누가 Object 만들어서 쓰는 방법을 Discussion에 올려줬다 .\nobject 생성 javascript 1 2 3 4 5 6 7 8 9 10 // 방법 1 let object = { method1: function(arg1) { // some code }, method2: function(arg2) { // some code } }; return object javascript 1 2 3 4 5 6 7 8 9 // 방법 2 let object = new Object(); object.method1 = function(arg) { // some code } object.method2 = function(arg) { // some code } return object 함수 생성 javascript 1 2 3 4 // 방법 1 functionNameOne: function(arg) =\u0026gt; { // do something.. return something.. } javascript 1 2 3 4 // 방법 2 functionNameOne(arg) { // do something.. return something.. } javascript 1 2 // 방법 3 functionNameOne: (arg) =\u0026gt; returnValue error 출력 javascript 1 throw new Error(\u0026#34;message\u0026#34;); 풀이 javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @param {string} val * @return {Object} */ var expect = function(val) { let object = { toBe: function(arg1) { if (arg1 === val) { return true } else { throw new Error(\u0026#34;Not Equal\u0026#34;); } }, notToBe: function(arg2) { if (arg2 !== val) { return true } else { throw new Error(\u0026#34;Equal\u0026#34;); } } }; return object }; ","date":"2025-09-19T18:38:00+09:00","permalink":"https://kimcatchy.github.io/p/leetcode-2704/","title":"To Be Or Not To Be"},{"content":"배열명 C에서 일차원 배열은 메모리에 연속적으로 할당\n배열명은 그 배열의 첫 번째 배열 요소를 가리키는 주소 값(\u0026amp;a[0])\n*a는 *(\u0026amp;a[0])이므로 a[0]의 값이 됨\n(포인터형) + 정수를 했을 때 실제 연산 결과는 (포인터형) + 정수*(대상의크기) → a + i = \u0026amp;a[i]\n포인터형끼리의 뺄셈은 두 주소 사이에 들어가는 변수의 개수\n포인터와 1차원 배열 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 int a[5], *b, i; int sum1=0, sum2=0, sum3=0, sum4=0; ... b = a; for(i=0; i\u0026lt;5; i++) { sum1 += a[i]; sum2 += *(a+i); sum3 += *(b+i); sum4 += b[i]; } a와 b가 동일한 것은 아님\nb는 배열이 아니지만 배열처럼 사용할 수 있음\n위에서 sum1~4를 출력할 경우 결과는 모두 같음\n배열명: 기호, 값을 바꿀 수 없음\n포인터: 변수, 값을 바꿀 수 있음\n위 코드에서 \u0026lsquo;a = a+1\u0026rsquo;은 불가능하지만 \u0026lsquo;b = b+1\u0026rsquo;은 가능\n포인터를 이용한 배열의 합 구하기 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 int a[5], *b, i; int sum=0; ... b = a; for (i=0; i\u0026lt;5; i++) { sum += *b++; } 배열 매개 변수 ↑ C 함수 에서 작성했던 배열 매개 변수에 대한 해석\n실제로는 여전히 값에 의한 호출임\n배열 첫 번째 요소의 주소가 복사\n포인터와 다차원 배열 c\u0026#43;\u0026#43; 1 2 3 int a[2][3]; int (*b)[3]; b = a; b를 2차원 배열인 것처럼 사용할 수 있음\n뒤의 크기를 반드시 맞춰야 함\n자료형 배열명[size1][size2]\u0026hellip;[sizen] → 자료형 (*변수명)[size2]\u0026hellip;[sizen]\n","date":"2025-09-19T18:29:00+09:00","permalink":"https://kimcatchy.github.io/p/pointer-and-array/","title":"포인터와 배열"},{"content":"문제 [object Promise]## 유클리드 호제법\n두 양의 정수 a, b (a \u0026gt; b)에 대하여 a = bq + r (0 ≤ r \u0026lt; b)이라 하면\na, b의 최대공약수는 b, r의 최대공약수와 같음 즉, gcd⁡(a, b) = gcd⁡(b, r)\nr이 0이라면 a, b의 최대공약수는 b\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 int euclidean(int a, int b) { while (b != 0) { int r = b;\t// b의 값을 r에 저장 b = a % b;\t// a를 b로 나눈 나머지를 b에 저장 a = r;\t// a에 r의 값(b의 초기값)을 저장 }\t// 최대공약수가 될 때까지 반복 return a; } 풀이 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int euclidean(int a, int b) { while (b != 0) { int r = b; b = a % b; a = r; } return a; } int* solution(int numer1, int denom1, int numer2, int denom2) { // return 값은 malloc 등 동적 할당을 사용해주세요. 할당 길이는 상황에 맞게 변경해주세요. int* answer = (int*)malloc(2 * sizeof(int)); int numer = numer1 * denom2 + numer2 * denom1; int denom = denom1 * denom2; int gcd = euclidean(numer, denom); answer[0] = numer / gcd; answer[1] = denom / gcd; return answer; ","date":"2025-09-19T18:22:00+09:00","permalink":"https://kimcatchy.github.io/p/c-gcd-algorithm/","title":"기약분수 알고리즘"},{"content":"큐 삽입과 삭제가 양 끝에서 각각 수행되는 자료구조\n일상생활의 은행, 병원 등에서 번호표를 이용한 줄서기가 대표적인 큐\n선입 선출(FIFO) 원칙 하에 item의 삽입과 삭제 수행\n삭제는 전단, 삽입은 후단\n큐 ADT 데이터: FIFO의 접근 방법을 유지하는 항목들의 모음\nQueue(): 비어 있는 새로운 큐 생성\nisEmpty(): 큐가 비어있으면 True, 아니면 False\nenqueue(x): 항목 x를 큐의 맨 뒤에 추가\ndequeue(): 큐의 맨 앞에 있는 항목을 꺼내 반환\npeek(): 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환\nsize(): 큐의 모든 항목들의 개수를 반환\nclear(): 큐를 공백상태로 만듦\n큐의 응용 CPU의 태스크 스케줄링\n네트워크 프린터\n실시간 시스템의 인터럽트 처리\n다양한 이벤트 구동 방식 컴퓨터 시뮬레이션\n콜 센터의 전화 서비스 처리 등\n이진트리의 레벨 순회(Level-order Traversal)\n그래프에서 너비우선탐색(Breath-First Search) 등\n선형 큐의 문제점 비효율적\nenqueue(item): 삽입 연산 → O(1)\ndequeue(): 삭제 연산 → O(n)\n리스트의 맨 앞에서 항목을 삭제하면 그 항목 이후의 모든 항목을 한 칸씩 앞으로 이동해야 하므로 매우 비효율적\n수행시간\n선형 큐 삽입 enqueue(item)의 수행시간: O(1) 시간 소요\n선형 큐 삭제 dequeue()의 수행시간: O(n) 시간 소요 (큐의 모든 항목들을 새 리스트로 복사)\n원형 큐 배열을 원형으로 사용\n전단과 후단을 위한 2개의 변수\nfront: 첫 번째 요소 하나 앞의 인덱스\nrear: 마지막 요소의 인덱스\n회전(시계방향) 방법\nfront ← (front + 1) % MAX_QSIZE\nrear ← (rear + 1) % MAX_QSIZE\n원형 큐의 삽입과 삭제 연산의 수행시간은 각각 O(1) 시간\n삽입 또는 삭제 연산이 rear와 front로 인해 연결리스트의 다른 노드들을 일일이 방문할 필요 없이 각 연산이 수행되기 때문 저장된 항목의 개수 = (rear - front + MAX_QSIZE) % MAX_QSIZE\n공백상태: front == rear\n포화상태: front % MAX_QSIZE == (rear + 1) % MAX_QSIZE\n원형 큐의 구현 파이썬 리스트 사용\n리스트의 크기가 미리 결정되어야 함 → 포화상태 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 MAX_QSIZE = 10 class CircularQueue: def __init__(self): self.front = 0 self.rear = 0 self.items = [None] * MAX_QSIZE def isEmpty(self): return self.front == self.rear def isFull(self): return self.front == (self.rear + 1) % MAX_QSIZE def clear(self): self.front = self.rear def enqueue(self, item): if not self.isFull(): self.rear = (self.rear + 1) % MAX_QSIZE self.items[self.rear] = item def dequeue(self): if not self.isEmpty(): self.front = (self.front + 1) % MAX_QSIZE return self.items[self.front] def peek(self): if not self.isEmpty(): return self.items[(self.front + 1) % MAX_QSIZE] def size(self): return (self.rear - self.front + MAX_QSIZE) % MAX_QSIZE def display(self): out = [] if self.front \u0026lt; self.rear: out = self.items[self.front + 1 : self.rear + 1] else: out = self.items[self.front + 1 : MAX_QSIZE] + self.items[0 : self.rear + 1] print(\u0026#34;[f=%s, r=%d] ==\u0026gt; \u0026#34;%(self.front, self.rear), out) q = CircularQueue() for i in range(8): q.enqueue(i) q.display() for i in range(5): q.dequeue(); q.display() for i in range(8,14): q.enqueue(i) q.display() bash 1 2 3 [f=0, r=8] ==\u0026gt; [0, 1, 2, 3, 4, 5, 6, 7] [f=5, r=8] ==\u0026gt; [5, 6, 7] [f=5, r=4] ==\u0026gt; [5, 6, 7, 8, 9, 10, 11, 12, 13] 파이썬의 queue 모듈 큐(Queue)와 스택(LifoQueue) 클래스 제공\n사용하기 위해 queue 모듈을 import 해야 함\npython 1 import queue 큐 객체 생성 python 1 Q = queue.Queue(maxsize=20) 함수 이름 변경: 삽입은 put(), 삭제는 get() python 1 2 3 4 5 6 for v in range(1, 10): Q.put(v) print(\u0026#34;큐의 내용:\u0026#34;, end = \u0026#39;\u0026#39;) for _ in range(1, 10): print(Q.get(), end = \u0026#39; \u0026#39;) print() queue 모듈을 사용한 원형 큐 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import queue class CircularQueue: def __init__(self): self.q = queue.Queue(maxsize=10) self.front = 0 self.rear = 0 def isEmpty(self): return self.q.empty() def isFull(self): return self.q.full() def clear(self): self.q = queue.Queue(maxsize=10) self.front = 0 self.rear = 0 def enqueue(self, item): if not self.isFull(): self.q.put(item) self.rear = (self.rear + 1) % 10 def dequeue(self): if not self.isEmpty(): item = self.q.get() self.front = (self.front + 1) % 10 return item def peek(self): if not self.isEmpty(): return list(self.q.queue)[0] def size(self): return self.q.qsize() def display(self): items = list(self.q.queue) print(f\u0026#39;[f={self.front}, r={self.rear}] ==\u0026gt; \u0026#39;, items) q = CircularQueue() for i in range(8): q.enqueue(i) q.display() for i in range(5): q.dequeue() q.display() for i in range(8,14): q.enqueue(i) q.display() 덱 Deque, Double-Ended QUEue\n스택이나 큐보다는 입출력이 자유로운,양쪽 끝에서 삽입과 삭제를 허용하는 자료구조\n여전히 중간에서 삽입과 삭제는 불가능 스택과 큐 자료구조를 혼합한 자료구조, 덱을 스택이나 큐로 사용할 수 있음\n덱 ADT 데이터: 전단과 후단을 통한 접근을 허용하는 항목들의 모음\nDeque(): 비어 있는 새로운 덱 생성\nisEmpty(): 덱이 비어있으면 True, 아니면 False\naddFront(x): 항목 x를 덱의 맨 앞에 추가\ndeleteFront(): 맨 앞의 항목을 꺼내서 반환\ngetFront(): 맨 앞의 항목을 꺼내지 않고 반환\naddRear(x): 항목 x를 덱의 맨 뒤에 추가\ndeleteRear(): 맨 뒤의 항목을 꺼내서 반환\ngetRear(): 맨 뒤의 항목을 꺼내지 않고 반환\nisFull(): 덱이 가득 차 있으면 True, 아니면 False\nsize(): 덱의 모든 항목들의 개수를 반환\nclear(): 덱을 공백상태로 만듦\n원형 덱의 연산 큐와 데이터는 동일\naddRear(), deleteFront(), getFront() 연산은 각각 큐의 enqueue, dequeue, peek 연산과 동일\n덱의 후단(rear)을 스택의 상단(top)으로 사용하면 addRear(), deleteFront(), getFront() 연산은 각각 스택의 push, pop, peek 연산과 정확히 동일\n원형 큐에서 추가된 연산: deleteRear(), addFront(), getRear()\n반시계방향 회전 필요(front, rear를 감소시킴)\nfront ← (front - 1 + MAX_QSIZE) % MAX_QSIZE\nrear ← (rear - 1 + MAX_QSIZE) % MAX_QSIZE\n덱의 구현 원형 큐를 상속하여 원형 덱 클래스를 구현 python 1 class CircularDeque(CircularQueue): 덱의 생성자 (상속되지 않으므로 자식이 부모의 생성자를 호출해야 함)\nfront, rear, items와 같은 멤버 변수는 추가로 선언하지 않음\n자식클래스에서 부모를 부르는 함수가 super()\npython 1 2 def __init__(self): Super().__init__() 재사용 멤버들: isEmpty, isFull, size, clear\n인터페이스 변경 멤버들\npython 1 2 3 def addRear(self, item): self.enqueue(item) def deleteFront(self): return self.dequeue()\t# 반환에 주의 def getFront(self): return self.peek()\t# 반환에 주의 추가로 구현할 메소드 python 1 2 3 4 5 6 7 8 9 10 11 12 13 def addFront(self, item): if not self.isFull(): self.items[self.front] = item self.front = self.front - 1 if self.front \u0026lt; 0: self.front = MAX_QSIZE - 1 def deleteRear(self): if not self.isEmpty(): item = self.items[self.rear] self.rear = self.rear - 1 if self.rear \u0026lt; 0: self.rear = MAX_QSIZE - 1 return item def getRear(self): return self.items[self.rear] 우선순위 큐 우선순위의 개념을 큐에 도입한 자료구조\n모든 데이터가 우선순위를 가짐\n입력 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력\n가장 일반적인 큐로 볼 수 있음\n어떤 요소가 먼저 삭제되는가에 따라 최대우선순위 큐와 최소우선순위 큐로 나뉨\n최대우선순위 큐: 가장 높은 값 먼저 삭제\n최소우선순위 큐: 가장 낮은 값 먼저 삭제\n우선순위를 어떻게 정하느냐에 따라 스택이나 큐로도 사용\n시뮬레이션, 네트워크 트래픽 제어, OS 작업 스케줄링 등\n우선순위 큐 ADT 데이터: 우선순위를 가진 요소들의 모음\nQueue(): 비어 있는 새로운 우선순위 큐 생성\nisEmpty(): 우선순위 큐가 비어있으면 True, 아니면 False\nenqueue(e): 우선순위를 가진 항목 e를 추가\ndequeue(): 가장 우선순위가 높은 항목을 꺼내서 반환\npeek(): 가장 우선순위가 높은 항목을 삭제하지 않고 반환\nsize(): 우선순위 큐의 모든 항목들의 개수를 반환\nclear(): 우선순위 큐를 공백상태로 만듦\n우선순위 큐의 구현 정렬되지 않은 배열을 이용한 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class PriorityQueue: def __init__(self): self.items = [] def isEmpty(self): return len(self.items) == 0 def size(self): return len(self.items) def clear(self): self.items = [] def enqueue(self, item): self.items.append(item) def findMaxIndex(self): if self.isEmpty(): return None else: highest = 0 for i in range(1, self.size()): if self.items[i] \u0026gt; self.items[highest]: highest = i return highest def dequeue(self): highest = self.findMaxIndex() if highest is not None: return self.items.pop(highest) def peek(self): highest = findMaxIndex() if highest is not None: return self.items[highest] q = PriorityQueue() q.enqueue(34) q.enqueue(18) q.enqueue(27) q.enqueue(45) q.enqueue(15) print(\u0026#34;PQueue:\u0026#34;, q.items) while not q.isEmpty(): print(\u0026#34;Max Priority = \u0026#34;, q.dequeue()) ","date":"2025-09-19T18:11:00+09:00","permalink":"https://kimcatchy.github.io/p/queue-and-deque/","title":"Queue \u0026 Deque"},{"content":"VS Code C++ extension 설치 3개 다 설치 MinGW-w64 toolchain 설치 [https://www.msys2.org/](https://www.msys2.org/) MSYS2 웹사이트에서 설치 프로그램을 다운로드\n설치 후 MSYS2 터미널에서 아래 명령어로 MinGW-w64 toolchain 설치\nbash 1 pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain Windows 환경 변수 PATH에 MinGW-w64의 bin 폴더 경로 추가 tasks.json json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: g++.exe build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;C:\\\\\\\\msys64\\\\\\\\mingw64\\\\\\\\bin\\\\\\\\g++.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${workspaceFolder}\\\\\\\\${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [\u0026#34;$gcc\u0026#34;], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;detail\u0026#34;: \u0026#34;Task generated by Debugger.\u0026#34; } ] } launch.json json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;C:\\\\\\\\msys64\\\\\\\\mingw64\\\\\\\\bin\\\\\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ] } ] } ","date":"2025-09-19T18:07:00+09:00","permalink":"https://kimcatchy.github.io/p/vscode-c-cpp/","title":"VSCode C/C++ 컴파일 환경 세팅"},{"content":"클래스와 객체 클래스(Class): 객체를 만들기 위한 틀 또는 설계도\n객체(Object): 클래스의 인스턴스, 실제로 메모리에 할당된 실체\npython 1 2 3 4 5 6 7 8 9 10 class Car: def __init__(self, color, brand): self.color = color self.brand = brand def drive(self): print(f\u0026#34;{self.color} {self.brand} 차를 운전합니다.\u0026#34;) my_car = Car(\u0026#34;빨간\u0026#34;, \u0026#34;테슬라\u0026#34;) my_car.drive() # 출력: 빨간 테슬라 차를 운전합니다. 속성과 메서드 속성(Attribute): 객체의 특성을 나타내는 변수\n메서드(Method): 객체가 수행할 수 있는 동작을 정의하는 함수\npython 1 2 3 4 5 6 7 8 9 10 11 class Person: def __init__(self, name, age): self.name = name # 속성 self.age = age # 속성 def greet(self): # 메서드 print(f\u0026#34;안녕하세요, 저는 {self.name}입니다.\u0026#34;) person = Person(\u0026#34;김철수\u0026#34;, 30) print(person.name) # 출력: 김철수 person.greet() # 출력: 안녕하세요, 저는 김철수입니다. 상속 Inheritance\n기존 클래스의 속성과 메서드를 새로운 클래스가 재사용할 수 있게 해줌\npython 1 2 3 4 5 6 7 8 9 10 11 class ElectricCar(Car): def __init__(self, color, brand, battery_capacity): super().__init__(color, brand) self.battery_capacity = battery_capacity def charge(self): print(f\u0026#34;{self.brand} 전기차를 충전합니다.\u0026#34;) electric_car = ElectricCar(\u0026#34;파란\u0026#34;, \u0026#34;현대\u0026#34;, \u0026#34;100kWh\u0026#34;) electric_car.drive() # Car 클래스의 메서드 사용 electric_car.charge() # ElectricCar 클래스의 메서드 사용 캡슐화 Encapsulation\n객체의 내부 데이터를 외부로부터 숨기고, 접근을 제어하는 메커니즘\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class BankAccount: def __init__(self, balance): self.__balance = balance # 비공개 속성 def deposit(self, amount): if amount \u0026gt; 0: self.__balance += amount def get_balance(self): return self.__balance account = BankAccount(1000) print(account.get_balance()) # 출력: 1000 account.deposit(500) print(account.get_balance()) # 출력: 1500 다형성 Polymorphism\n같은 이름의 메서드가 다른 클래스에서 다르게 동작할 수 있게 해줌\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Animal: def speak(self): pass class Dog(Animal): def speak(self): return \u0026#34;멍멍!\u0026#34; class Cat(Animal): def speak(self): return \u0026#34;야옹!\u0026#34; def animal_sound(animal): print(animal.speak()) dog = Dog() cat = Cat() animal_sound(dog) # 출력: 멍멍! animal_sound(cat) # 출력: 야옹! ","date":"2025-09-19T17:51:00+09:00","permalink":"https://kimcatchy.github.io/p/object-oriented-programming/","title":"Object-Oriented Programming"},{"content":"포인터 변수의 설정 = 메모리에서 변수로 사용할 공간을 할당 받음\n메모리: 값 등을 저장할 수 있는 공간\n메모리 주소: 메모리의 각 byte 공간에는 주소라는 번호가 붙어있음\n변수의 주소: 변수를 차지하고 있는 공간들의 주소들 중 가장 작은 것\n주소 연산자 \u0026amp;: 변수의 주소가 결과값\n포인터: 변수의 주소를 저장할 수 있는 변수\n간접 지정 연산자 *: 포인터에 들어 있는 주소가 가리키는 그 공간(대상체)\n$$ 포인터의 대입 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 int a; double b; int *c; double *d; c = \u0026amp;a; d = \u0026amp;b; 포인터의 자료형 포인터는 가리키는 대상의 자료형으로 자료형을 구분\n가리키는 대상이 다르면 대입하지 말 것\n의도적으로 한다면 형변환 연산자 사용\nc\u0026#43;\u0026#43; 1 2 3 4 5 int a, *c; double b, *d; c = \u0026amp;a; d = \u0026amp;b; c = (int *)\u0026amp;b; 포인터의 활용 함수: 참조에 의한 호출 모사\n배열\n자료구조\n문자열\n파일 입출력\n두 변수의 값을 바꾸는 함수 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 include \u0026lt;stdio.h\u0026gt; void swap(int *a, int *b) { int tmp; tmp = *a; *a = *b; *b = tmp; return; } int main(void) { int x, y x = 8; y = 12; swap(\u0026amp;x, \u0026amp;y); ... } 합과 차를 구하는 함수 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sum_diff(int a, int b, int *c, int *d) { *c = a + b; *d = a - b; return; } int main(void) { int x, y; int p, m; x = 8; y = 12; sum_diff(x, y, \u0026amp;p, \u0026amp;m); ... } 포인터를 통해 함수가 반환값이 2개 이상인 것처럼 동작하게 할 수 있음 포인터 + 선택 정렬 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; void swap(int* a, int* b) { int tmp; tmp = *a; *a = *b; *b = tmp; return; } int main(void) { int i, j, a[10]; int min, idx; for (i = 0; i \u0026lt; 10; i++) { scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (i = 0; i \u0026lt; 9; i++) { min = a[i]; idx = i; for (j = i; j \u0026lt; 10; j++) { if (a[j] \u0026lt; min) { min = a[j]; idx = j; } } swap(\u0026amp;a[i], \u0026amp;a[idx]); } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\\\\n\u0026#34;, a[i]); } } ","date":"2025-09-19T17:41:00+09:00","permalink":"https://kimcatchy.github.io/p/c-pointer/","title":"포인터"},{"content":"알고리즘 잘 정의되고 명백한 규칙들의 집합 또는 유한 번의 단계 내에서 문제를 풀기 위한 과정\n프로그램에서 가장 핵심적인 부분\n선택 정렬 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i, j, a[10]; int min, idx; int tmp; for (i=0; i\u0026lt;10; i++) { scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (i = 0; i \u0026lt; 9; i++) { min = 99999; for (j = i; j \u0026lt; 10; j++) { if (a[j] \u0026lt; min) { min = a[j]; idx = j; } } tmp = a[idx]; a[idx] = a[i]; a[i] = tmp; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\\\\n\u0026#34;, a[i]); } } 10개의 수를 입력 받아 저장한 뒤 오름차순으로 정렬하여 출력\n최초의 min 값은 크게 설정\n","date":"2025-09-19T17:37:00+09:00","permalink":"https://kimcatchy.github.io/p/selection-sort/","title":"선택 정렬 알고리즘"},{"content":"스택 후입선출(LIFO: Last-In First-Out), 가장 최근에 들어온 데이터가 가장 먼저 나감\n저장되는 내용: 숫자, 문자열, 클래스 객체, 리스트 등 모든 자료 가능\n되돌리기, 함수 호출, 괄호 검사, 후위 표기식 계산, 중위 표기식의 후위 표기식 변환 등에 사용\n기본 기능 추가 기능 isEmpty 스택이 비어있는지 확인 clear 스택 비움 puh 스택의 맨 마지막에 항목 추가 peek 스택의 맨 마지막 항목 반환 pop 스택의 맨 마지막 항목 삭제 size 스택 크기 확인 Stack ADT 스택의 추상자료형\n데이터: 후입선출의 접근 방법을 유지하는 항목들의 모음\n연산 결과 Stack() 비어있는 새로운 스택 생성 isEmpty() 스택이 비어있으면 True, 아니면 False push(e) 항목 e를 스택의 맨 위에 추가 pop() 스택의 맨 위에 있는 항목을 꺼내 반환 peek() 스택의 맨 위에 있는 항목을 삭제하지 않고 반환 size() 스택 내의 모든 항목들의 개수 반환 clear() 스택을 공백 상태로 만듦 스택의 구현 데이터\ntop: 스택 항목을 저장하는 파이썬 리스트\n항목의 개수는 len(top)으로 구할 수 있음\n연산: isEmpty, push, pop, peek, display\n항목 삽입/삭제 위치: 리스트의 맨 뒤가 유리\n함수를 이용한 스택의 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 top = [] def isEmpty(): return len(top) == 0 def push(item): top.append(item) def pop(): if not isEmpty(): return top.pop(-1) def peek(): if not isEmpty(): return top[-1] def size(): return len(top) def clear(): global top\t# top은 전역변수임을 지정 top = [] 클래스를 이용한 스택의 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Stack: def __init__(self): self.top = [] def isEmpty(self); return len(self.top) == 0 def size(self); return len(self.top) def clear(self): self.top = [] def push(self, item): self.top.append(item) def pop(self): if not self.isEmpty(): return self.top.pop(-1) def peek(self): if not self.isEmpty(): return self.top[-1] 괄호 검사 검사 조건 왼쪽 괄호의 개수와 오른쪽 괄호의 개수는 같아야 함\n같은 타입의 괄호에서 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 함\n서로 다른 타입의 괄호 쌍이 서로 교차하면 안됨\n검사 방법 문자를 저장하는 스택을 준비, 처음에는 공백 상태가 되어야 함\n입력 문자열의 문자를 하나씩 읽어 왼쪽 괄호를 만나면 스택에 삽입\n오른쪽 괄호를 만나면 pop() 연산으로 가장 최근에 삽입된 괄호를 꺼냄, 이때 스택이 비어있으면 조건 ②에 위배\n꺼낸 괄호가 오른쪽 괄호와 짝이 맞지 않으면 조건 ③에 위배\n끝까지 처리했는데 스택에 괄호가 남아 있으면 조건 ①에 위배\n괄호 검사 알고리즘 python 1 2 3 4 5 6 7 8 9 10 11 12 13 def checkBrackets(statement): stack = Stack() for ch in statement: if ch in (\u0026#39;{\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;(\u0026#39;): stack.push(ch) elif ch in (\u0026#39;}\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;)\u0026#39;): if stack.isEmpty(): return False\t# 조건 2 위반 else: left = stack.pop() if (ch==\u0026#34;}\u0026#34; and left!=\u0026#34;{\u0026#34;) or (ch==\u0026#34;]\u0026#34; and left!=\u0026#34;[\u0026#34;) or (ch==\u0026#34;)\u0026#34; and left!=\u0026#34;(\u0026#34;): return False\t# 조건 3 위반 return stack.isEmpty()\t# False면 조건 1 위반 수식의 계산 수식의 표기 방법 전위 (prefix) 중위 (infix) 후위 (postfix) 연산자 피연산자1 피연산자2 피연산자1 연산자 피연산자2 피연산자1 피연산자2 연산자 + 1 2 1 + 2 1 2 + + 3 * 1 2 3 + 1 * 2 3 1 2 * + 사람들은 중위표기법에 익숙하지만 컴퓨터는 후위표기가 효율적 후위 표기 수식 계산 알고리즘 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def evalPostfix(expr): s = Stack() for token in expr: if token in \u0026#34;+-*/\u0026#34;: val2 = s.pop() val1 = s.pop() if (token == \u0026#39;+\u0026#39;): s.push(val1 + val2) elif (token == \u0026#39;-\u0026#39;): s.push(val1 - val2) elif (token == \u0026#39;*\u0026#39;): s.push(val1 * val2) elif (token == \u0026#39;/\u0026#39;): s.push(val1 / val2) else:\t# 항목이 피연산자이면 실수로 변경해서 스택에 저장 s.push(float(token)) return s.pop() 중위 표기 수식의 후위 표기 변환 알고리즘 피연산자를 만나면 그대로 출력\n연산자를 만나면 현재 스택의 맨 위에 있는 연산자보다 높거나 같으면 맨 위 연산자가 나오고(계산한 후) 자신(낮은 연산자)을 push\n왼쪽 괄호는 우선순위가 가장 낮은 연산자로 취급\n오른족 괄호가 나오면 스택에서 왼쪽 괄호 위에 쌓여있는 모든 연산자를 출력\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def precedence(op): if op==\u0026#39;(\u0026#39; or op==\u0026#39;)\u0026#39;: return 0 elif op==\u0026#39;+\u0026#39; or op==\u0026#39;-\u0026#39;: return 1 elif op==\u0026#39;*\u0026#39; or op==\u0026#39;/\u0026#39;: return 2 else: return -1 def Infix2Postfix(expr): s = Stack() output = [] for term in expr: if term in \u0026#39;(\u0026#39;: s.push(\u0026#39;)\u0026#39;) elif term in \u0026#39;)\u0026#39;: while not s.isEmpty(): op = s.pop() if op == \u0026#39;(\u0026#39;: break; else: output.append(op) elif term in \u0026#34;+-*/\u0026#34;: while not s.isEmpty(): op = s.peek() if(precedence(term) \u0026lt;= precedence(op)): output.append(op) s.pop() else: break s.push(term) else: output.append(term) while not s.isEmpty(): output.append(s.pop()) return output 수식 계산 스크립트 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Stack: def __init__(self): self.top = [] def isEmpty(self): return len(self.top) == 0 def size(self): return len(self.top) def clear(self): self.top = [] def push(self, item): self.top.append(item) def pop(self): if not self.isEmpty(): return self.top.pop(-1) def peek(self): if not self.isEmpty(): return self.top[-1] def precedence(op): if op == \u0026#39;(\u0026#39; or op == \u0026#39;)\u0026#39;: return 0 elif op == \u0026#39;+\u0026#39; or op == \u0026#39;-\u0026#39;: return 1 elif op == \u0026#39;*\u0026#39; or op == \u0026#39;/\u0026#39;: return 2 else: return -1 def Infix2Postfix(expr): s = Stack() output = [] for term in expr: if term == \u0026#39;(\u0026#39;: s.push(term) elif term == \u0026#39;)\u0026#39;: while not s.isEmpty() and s.peek() != \u0026#39;(\u0026#39;: output.append(s.pop()) if not s.isEmpty() and s.peek() == \u0026#39;(\u0026#39;: s.pop() elif term in \u0026#34;+-*/\u0026#34;: while not s.isEmpty() and precedence(term) \u0026lt;= precedence(s.peek()): output.append(s.pop()) s.push(term) else: output.append(term) while not s.isEmpty(): output.append(s.pop()) return output def evalPostfix(expr): s = Stack() for token in expr: if token in \u0026#34;+-*/\u0026#34;: val2 = s.pop() val1 = s.pop() if token == \u0026#39;+\u0026#39;: s.push(val1 + val2) elif token == \u0026#39;-\u0026#39;: s.push(val1 - val2) elif token == \u0026#39;*\u0026#39;: s.push(val1 * val2) elif token == \u0026#39;/\u0026#39;: s.push(val1 / val2) else: s.push(float(token)) return s.pop() def calculate_expression(expr): # 공백 제거 및 토큰화 tokens = [token.strip() for token in expr.replace(\u0026#39;(\u0026#39;, \u0026#39; ( \u0026#39;).replace(\u0026#39;)\u0026#39;, \u0026#39; ) \u0026#39;).split()] postfix = Infix2Postfix(tokens) result = evalPostfix(postfix) return result # 메인 프로그램 if __name__ == \u0026#34;__main__\u0026#34;: while True: expr = input(\u0026#34;계산할 수식을 입력하세요 (종료하려면 \u0026#39;q\u0026#39; 입력): \u0026#34;) if expr.lower() == \u0026#39;q\u0026#39;: break try: result = calculate_expression(expr) print(f\u0026#34;결과: {result}\u0026#34;) except Exception as e: print(f\u0026#34;오류 발생: {e}\u0026#34;) ","date":"2025-09-19T16:57:00+09:00","permalink":"https://kimcatchy.github.io/p/stack/","title":"Stack"},{"content":"문장 \u0026amp; 블록 조건문과 반복문에서 중괄호가 없으면 문장을 하나씩만 기술\n{ } (블록): 하나의 문장이 들어가는 자리에 여러 개의 문장을 기술하고자 할 때 사용\n중괄호가 없을 때 else는 아직 짝 지어지지 않은 if들 중 가장 가까이 위치한 if와 짝\n코딩 스타일 들여쓰기 C에서의 공백과 줄 바꿈: 단어/의미를 구별하는 용도\n들여쓰기: 블록 안의 문장은 블록보다 안쪽에 작성, 문법적 의미는 없으나 보기 편하게 하기 위함\n중괄호의 위치 K\u0026amp;R c\u0026#43;\u0026#43; 1 2 3 4 if (...) { ...; ...; } BSD c\u0026#43;\u0026#43; 1 2 3 4 5 if (...) { ...; ...; } GNU c\u0026#43;\u0026#43; 1 2 3 4 5 if (...) { ...; ...; } 변수 범위 블록의 범위가 겹치는 경우 원칙적으로 가장 안 쪽 범위의 변수로 간주\n내부 변수(지역 변수)\n어떤 블록 내에서 선언 및 정의된 변수\n그 블록 내에서만 의미를 가짐\n외부 변수(전역 변수)\n어떤 블록에도 속하지 않는 변수 (블록 밖에서 선언)\n프로그램 전체에서 의미를 가짐\n내부 변수와 외부 변수의 차이점 내부 변수 외부 변수 선언된 블록이 시작될 때 생성 프로그램이 시작될 때 생성 여러 번 생성 가능 한 번만 생성 생성 될 때 초기화 생성될 때 초기화 초기화 값을 지정하지 않은 경우 초기화 X 초기화 값을 지정하지 않은 경우 0으로 초기화 블록이 끝나면 소멸 프로그램이 끝나면 소멸 선언된 블록 내에서만 유효 프로그램 전체에서 유효 정적 변수 (내부) 정적 변수\n함수 등의 내부에서 선언\n선언할 때 앞에 static을 붙임\n프로그램이 시작될 때 생성되고 끝날 때 소멸\n초기화는 프로그램 시작될 때 한번\n초기화 값을 지정하지 않으면 0으로 초기화\n함수 등의 내부에서만 사용 가능\n전역 변수는 모든 함수에서 변수를 읽거나 쓸 수 있어 편리하지만, 어느 함수에서 어떻게 바뀌는지 추적하기 어려워 프로그램 버그 해결이 어려워질 수 있음\n프로그램이 동작하는 한 유지하는 외부 변수 + 블록 내부에서만 사용 가능 한 내부 변수의 성질\n","date":"2025-09-19T16:52:00+09:00","permalink":"https://kimcatchy.github.io/p/variable-scope/","title":"변수 범위"},{"content":"리스트 항목들이 순서대로 나열되어 있고, 각 항목들은 위치를 가짐\nL = [item₀, item₁, item₂, \u0026hellip; , itemₙ₋₁]\n항목의 중복 가능\n임의의 위치에서도 항목의 삽입과 삭제가 가능\nStack, Queue, Deque를 모두 리스트로 구현 가능 (자료의 접근 위치 차이)\n리스트 ADT List(): 비어있는 새로운 리스트를 만듦\ninsert(pos, e): pos 위치에 새로운 요소 e 삽입\ndelete(pos): pos 위치에 있는 요소를 꺼내고(삭제) 반환\nisEmpty(pos): 리스트가 비어있는지를 검사\ngetEntry(pos): pos 위치에 있는 요소 반환\nsize(): 리스트 안의 요소의 개수 반환\nclear(): 리스트 초기화\nfind(item): 리스트에서 item이 있는지 찾아 인덱스 반환\nreplace(pos, item): pos에 있는 항목을 item으로 바꿈\nsort(): 리스트의 항목들을 어떤 기준으로 정렬함\nmerge(1st): 다른 리스트 1st를 리스트에 추가\ndisplay(): 리스트를 화면에 출력\nappend(e): 리스트의 맨 뒤에 새로운 항목을 추가함\n리스트의 구현 배열 구조 구현이 간단\n항목 접근이 0(1)\n삽입, 삭제 시 오버헤드\n항목의 개수 제한\n연결된 구조 구현이 복잡\n항목 접근이 0(n)\n삽입, 삭제가 효율적\n크기가 제한되지 않음\n리스트 용어 정리 파이썬 리스트\nC언어에서의 배열이 진화된 형태의 스마트한 배열\n배열 또는 배열 구조의 의미로 사용\n어떤 자료구조를 구현하기 위한 하나의 방법으로 사용\n연결 리스트\n자료들이 일렬로 나열할 수 있는 연결된 구조\n배열 구조(파이썬의 리스트)에 대응되는 의미로 사용\n자료구조 리스트\n추상적인 의미의 자료구조 리스트를 의미\n위에서 정의한 리스트의 ADT를 구현하기 위해 배열 구조나 연결된 구조를 사용할 것\n파이썬 리스트 C언어의 배열: 선언과 동시에 크기 확정\n파이썬 리스트는 클래스로 구현하여 멤버 함수 append(), insert()를 통해 크기를 늘릴 수 있음\n동적 배열이기 때문에 추가적인 공간이 필요하면 기존의 메모리를 모두 버리고 더 큰 메모리를 할당해 사용\n시간 복잡도\nappend(e) 연산: 대부분의 경우 0(1)\ninsert(pos, e) 연산: 0(n)\npop(pos) 연산: 0(n)\n배열로 구현한 리스트 자료구조 리스트의 ADT 구현에 파이썬 리스트 이용\n함수 버전: 전역변수와 함수로 구현\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 items=[]\t# 리스트 항목 작성을 위한 파이썬 리스트 def insert(pos, elem):\t# pos 위치에 새로운 요소 item 삽입 items.insert(pos, elem)\t# 파이썬 리스트 클래스의 insert 연산 def delete(pos):\t# pos 위치에 있는 요소를 꺼내고 반환 return items.pop(pos)\t# 파이썬 리스트 클래스의 pop 연산 def getEntry(pos): return items[pos]\t# pos번째 항목 반환 def isEmpty(): return len(items)=0\t# 크기가 0이면 True, 아니면 False def size(): return len(items)\t# 리스트의 크기 반환, len() 함수 이용 def clear(): items=[]\t# items를 초기화 → 오류 def find(item): return items.index(item)# 탐색 후 인덱스 반환 def replace(pos, elem): items[pos]=elem\t# pos번째 항목 변경 def sort(): items.sort()\t# 정렬(sort)메소드 이용 def merge(1st): items.extend(1st)\t# 병합(확장) def display(msg=\u0026#39;ArrayList\u0026#39;):\t# 출력: 디폴트 인수 사용 print(msg, size(), items)\t# 메시지크기+배열내용 출력 클래스 버전 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ArrayList: def __init__(self): self.items = [] def insert(self, pos, elem): self.items.insert(pos, elem) def delete(self, pos): return self.items.pop(pos) def isEmpty(self): return self.size() == 0 def getEntry(self, pos): return self.items[pos] def size(self): return len(self.items) def clear(self): self.items = [] def find(self, item): return self.items.index(item) def replace(self, pos, elem): self.items[pos] = elem def sort(self): self.items.sort() def merge(self, lst): self.items.extend(1st) def display(self, msg=\u0026#39;ArrayList\u0026#39;): print(msg, \u0026#39;항목수=\u0026#39;, self.size(), self.items) ## 집합 원소의 중복을 허용하지 않음\n원소들 사이에 순서가 없음 = 선형 자료구조가 아님\nS = {item₀, item₁, item₂, \u0026hellip; , itemₙ₋₁}\n집합 ADT 데이터: 같은 유형의 유일한 요소들의 모임, 원소들의 순서는 없지만 서로 비교할 수 있어야 함\nset(): 비어 있는 새로운 집합 생성\nsize(): 집합의 원소의 개수 반환\ncontains(e): 집합이 원소 e를 포함하는지를 검사하고 반환\ninsert(e): 새로운 원소 e를 삽입(이미 있다면 삽입하지 않음)\ndelete(e): 원소 e를 집합에서 꺼내고(삭제) 반환\nequals(setB): setB와 같은 집합인지 검사\nunion(setB): setB와의 합집합을 만들어 반환\nintersect(setB): setB와의 교집합을 만들어 반환\ndifference(setB): setB와의 차집합을 만들어 반환\ndisplay(): 집합을 화면에 출력\n리스트로 구현한 집합 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Set: def __init__(self): self.items = [] def size(self): return len(self.items) def display(self, msg): print(msg, self.items) def contains(self, item):\t# 1번 return item in self.items def contains(self, item):\t# 2번 for i in range(len(self.items)): if self.items[i] == item: return True return False def insert(self, elem): if elem not in self.items: self.items.append(elem) def delete(self, elem): if elem in self.items: self.items.remove(elem) def union(self, setB): setC = Set() setC.items = list(self.items) for elem in setB.items: if elem not in self.items: setC.items.append(elem) return setC def intersect(self, setB): setC = Set() for elem in setB.items: if elem in self.items: setC.items.append(elem) return setC def difference(self, setB): setC = Set() for elem in self.items: if elem not in setB.items: setC.items.append(elem) return setC ","date":"2025-09-19T15:58:00+09:00","permalink":"https://kimcatchy.github.io/p/list-and-set/","title":"List \u0026 Set"},{"content":"자료형 문자열 single quote, double quote 둘 다 사용 가능\n배열처럼 msg라는 문자열에 msg\n\\[n\\]을 하면 앞에서 n+1번째 글자, msg\n\\[-n\\]이면 뒤에서 n번째 글자\nC에서 %d로 변수의 값을 쓰는 것처럼 문자열에 다른 변수의 값을 적용할 수 있음\npython 1 2 3 4 hobby = \u0026#34;테니스\u0026#34; age = 21 score = 4.5 msg = \u0026#34;취미=%s, 나이=%d, 학점=%f\u0026#34; %(hobby, age, score) 리스트 크기가 자유롭고 다양한 타입의 데이터를 추가할 수 있는 배열\n메소드\ns.append(item): 항목 item을 리스트 s의 맨 뒤에 추가\ns.extend(lst): 리스트 lst를 s에 추가\ns.count(item): 리스트에서 항목 item의 개수를 세고 그 개수를 반환\ns.index(item,\\[시작\\],\\[종료\\]): 리스트에서 항목 item을 찾아 가장 작은 인덱스를 반환, 탐색의 시작 위치와 종료 위치 지정 가능\ns.insert(pos,item): pos 위치에 항목 item을 삽입\ns.pop(pos): pos 위치의 항목을 s에서 꺼내고 반환\ns.remove(item): 항목 item을 s에서 제거\ns.reverse(): 리스트 항목의 순서를 뒤집음\ns.sort(\\[key\\],\\[reverse\\]): 항목 정렬\n튜플 리스트와 동일하지만 크기나 값을 변경할 수 없음 딕셔너리 key와 관련된 value로 이루어진 항목들의 집합 python 1 2 3 map = {\u0026#39;사과\u0026#39;:\u0026#39;apple\u0026#39;, \u0026#39;바나나\u0026#39;:\u0026#39;banana\u0026#39;} search = input(\u0026#34;과일의 한글 이름을 입력해주세요: \u0026#34;) print(\u0026#34;%s는 영어로 %s 입니다.\u0026#34; %(search, map[search])) 집합 set과 frozenset(내용을 변경할 수 없는 set)이 있음\ns1.union(s2): s1과 s2의 합집합\ns1.intersection(s2): s1과 s2의 교집합\ns3 = s1 - s2: 차집합\n함수 파이썬 내장 함수(type, len, ord 등)\n사용자 정의 함수\npython 1 2 3 4 5 6 7 8 9 def find_max(A):\t# 함수 헤더 maximum = A[0]\t# 함수 몸체 ↓ for i in range(1, len(A)): if maximum \u0026lt; A[i]: maximum = A[i] return maximum data = [5, 3, 8, 4, 9, 1, 6, 2, 7] print(\u0026#34;max number =\u0026#34;, find_max(data)) 함수의 결과값을 반환할 때 여러 개의 값을 반환할 수 있음 python 1 2 3 4 5 6 7 8 9 10 11 def find_min_max(A):\t# 함수 헤더 maximum = A[0]\t# 함수 몸체 ↓ minimum = A[0] for i in range(1, len(A)): if maximum \u0026lt; A[i]: maximum = A[i] if minimum \u0026gt; A[i]: minimum = A[i] return maximum, minimum data = [5, 3, 8, 4, 9, 1, 6, 2, 7] x, y = find_min_max(data) print(\u0026#34;(max, min) =\u0026#34;, (x, y))\t# 튜플로 만들어 출력 디폴트 인수 python 1 2 3 4 5 6 7 8 def sum_range(begin, end, step=1): summ = 0 for n in range(begin, end, step): summ += n return summ print(\u0026#34;sum =\u0026#34;, sum_range(1, 10)) print(\u0026#34;sum =\u0026#34;, sum_range(1, 10, 2)) step의 디폴트 값을 1로 지정\nstep의 값을 지정하지 않고 range를 110으로 할 경우 110의 합인 45 출력\nstep을 2로 지정할 경우 1, 3, 5, 7, 9의 합인 25 출력\n키워드 인수 python 1 2 print(\u0026#34;sum =\u0026#34;, sum_range(step=3, begin=1, end=10)) print(\u0026#34;game \u0026#34;, end=\u0026#34;\u0026#34;) 순서에 상관 없이 인수의 값을 따로 입력할 수도 있음\nend=\u0026quot;\u0026quot; → 라인피드가 발생하지 않음\n변수의 범위 내장 범위(built-in scope)\n언어의 일부로 정의된 변수와 리터럴들\n프로그램의 어디에서나 사용할 수 있음\n전역 범위(global scope)\n소스 파일의 맨 꼭대기 레벨(함수나 클래스 밖)에서 생성\n프로그램의 어디에서나 사용할 수 있음\n지역 범위(local scope)\n함수나 클래스의 멤버함수(메소드) 안에서 생성\n그 안에서만 사용, 함수의 매개변수들도 지역범위\n인스턴스 범위(instance scope)\n클래스의 데이터 멤버로 생성된 변수\n클래스 내의 다른 함수들에서 사용할 수 있음\n모듈 \u0026amp; namespace python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 파일명: min_max.py def find_min_max(A): ... return min, max # 파일명: summ.py def sum_range(begin, end, step=1): ... return summ # 파일명: my_job.py import min_max.py from summ import *\t# 두 방식 모두 사용 가능 data = [5,3,8,4,9,1,6,2,7] print(\u0026#34;(min,max) =\u0026#34;, min_max.find_min_max(data)) print(\u0026#34;sum =\u0026#34;, summ.sum_range(1,10)) OOP 기본 개념 객체 지향 프로그래밍을 통해 코드를 더 모듈화하고, 재사용성을 높이며, 복잡한 시스템을 더 쉽게 모델링할 수 있음\n객체(Object)\n데이터(속성)와 이를 조작하는 메서드(함수)를 포함하는 독립적인 단위\n실제 세계의 엔티티를 모델링하는 데 사용\n클래스(Class)\n객체를 생성하기 위한 템플릿 또는 청사진\n객체의 구조와 행동을 정의\n인스턴스(Instance)\n클래스를 바탕으로 생성된 구체적인 객체\n각 인스턴스는 고유한 속성 값을 가질 수 있음\nPython에서의 클래스 구현 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student: def __init__(self, name, age, grade): self.name = name self.age = age self.grade = grade def introduce(self): return f\u0026#34;안녕하세요, 저는 {self.name}이고 {self.age}살입니다.\u0026#34; def study(self, subject): return f\u0026#34;{self.name}이(가) {subject}을(를) 공부하고 있습니다.\u0026#34; def get_grade(self): return f\u0026#34;{self.name}의 학년은 {self.grade}학년입니다.\u0026#34; 생성자(init):\n객체가 생성될 때 자동으로 호출되는 특별한 메서드\n객체의 초기 상태를 설정\nself는 객체 자신을 가리키는 참조\n속성(Attributes):\nself.name , self.age, self.grade는 객체의 속성\n각 객체의 상태를 나타냄\n메서드(Methods):\nintroduce(), study(), get_grade()는 클래스의 메서드\n객체의 행동을 정의\n첫 번째 매개변수로 항상 self를 받음\n객체 생성 및 사용 python 1 2 3 4 5 6 7 8 # 객체 생성 student1 = Student(\u0026#34;김철수\u0026#34;, 15, 1) student2 = Student(\u0026#34;이영희\u0026#34;, 16, 2) # 메서드 호출 print(student1.introduce()) # 출력: 안녕하세요, 저는 김철수이고 15살입니다. print(student2.study(\u0026#34;수학\u0026#34;)) # 출력: 이영희이(가) 수학을(를) 공부하고 있습니다. print(student1.get_grade()) # 출력: 김철수의 학년은 1학년입니다. Student 클래스의 인스턴스 두 개 생성\n각 인스턴스는 고유한 속성 값을 가짐\n객체의 메서드를 호출하여 다양한 작업을 수행할 수 있음\n연산자 중복 Operator Overloading\n클래스에 대해 연산자의 동작을 재정의하는 것\n이를 통해 사용자 정의 객체에 대해 기본 연산자(+, -, *, / 등)를 사용할 수 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; v1 = Vector(1, 2) v2 = Vector(3, 4) v3 = v1 + v2 # __add__ 메서드 호출 print(v3) # 출력: Vector(4, 6) 상속 Inheritance\n기존 클래스의 속성과 메서드를 새로운 클래스가 물려받는 것\n이를 통해 코드 재사용성을 높이고 계층 구조를 만들 수 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name}이(가) 멍멍!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name}이(가) 야옹!\u0026#34; dog = Dog(\u0026#34;바둑이\u0026#34;) cat = Cat(\u0026#34;나비\u0026#34;) print(dog.speak()) # 출력: 바둑이이(가) 멍멍! print(cat.speak()) # 출력: 나비이(가) 야옹! 재정의 Method Overriding\n부모 클래스의 메서드를 자식 클래스에서 새롭게 정의하는 것\n이를 통해 같은 이름의 메서드가 다른 동작을 할 수 있음\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Shape: def area(self): return 0 class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14 * self.radius ** 2 rect = Rectangle(5, 4) circle = Circle(3) print(rect.area()) # 출력: 20 print(circle.area()) # 출력: 28.26 ","date":"2025-09-19T12:44:00+09:00","permalink":"https://kimcatchy.github.io/p/py-types-and-function/","title":"Python 자료형 \u0026 함수"},{"content":"자료형과 리터럴 수치\n정수(int): 4, -7, Oxfffe, 073, \u0026hellip;\n실수(float): 3.14, -5.242, 123.123E-13, \u0026hellip;\n복소수(complex): complex(1,2), 1+2j, \u0026hellip;\n부울(bool): true, false\n시퀀스\n문자열(str): 'aaa', \u0026quot;BBB\u0026quot;, \u0026hellip;\n리스트(list): [], [1, 'bbb', 3.14], \u0026hellip;.\n튜플(tuple): (1, 2, 3), ('aaa', 'bbb', 'bbb'), \u0026hellip;\n매핑\n딕셔너리(dict): {3.14: \u0026quot;pi\u0026quot;, 4.5: \u0026quot;score\u0026quot;}, \u0026hellip; 집합(set, frozenset): {1, 2, 3}, {'aaa', 'bbb', 'bbb'}, \u0026hellip;\n변수 변수 선언 X\n파이썬에서는 모든 자료가 클래스로부터 만들어진 객체임\n변수는 다른 객체를 참조하는 참조자 또는 포인터의 역할을 함\n연산 나눗셈 연산의 경우 /로 실수 연산, //로 정수 연산(몫만)\n이항 연산자: **\n관계 연산자: \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=, ==, !=\n불 연산자: ||, \u0026amp;\u0026amp;, ! → or, and, not\nin / not in 연산자: 'a' in 'banana' → True\n함수 함수 호출: Y = sum(a, b) → 함수 sum 호출, 인수 2개\n키보드 입력 함수: input()\n화면 출력 함수: print()\n\\\\ Backlash\n\\n New line\n\\\u0026quot; Double quote\n\\' Single quote\n\\t Horizontal tab\n제어구조와 반복 판단문 python 1 2 3 4 5 6 7 8 if value % 2 == 0 : print(\u0026#34;짝수\u0026#34;) else : print(\u0026#34;홀수\u0026#34;) if score \u0026gt;= 90: grade = \u0026#34;A\u0026#34; elif score \u0026gt;= 80: grade = \u0026#34;B\u0026#34; elif score \u0026gt;= 70: grade = \u0026#34;C\u0026#34; else: grade = \u0026#34;F\u0026#34; 판단문 (분기-branching): if, else, elif\n블럭 지정은 들여쓰기로 함\n반복문 python 1 2 3 4 5 6 7 8 dan = int(input(\u0026#34;구구단 단 입력:\u0026#34;)) for n in range (2, 10, 1) : print(\u0026#34;%2d x %2d = %2d\u0026#34;% (dan, n, dan*n)) m = 2 while m \u0026lt; 10: print(\u0026#34;%2d x %2d= \u0026#34;% (dan, m), dan*m) m += 1 python 1 2 3 4 5 6 for n in range(5)\t# n: 0, 1, 2, 3, 4 for n in range(2, 10)\t# n: 2, 3, ... , 9 for n in range(10, 3, -2)\t# n: 10, 8, 6, 4 for item in[12, 33, 52, 26, 99]\t# 리스트의 모든 항목에 대해 반복 for c in \u0026#34;Game Over !\u0026#34;\t# 문자열의 각 문자에 대해 반복(G ~ !) ","date":"2025-09-19T12:35:00+09:00","permalink":"https://kimcatchy.github.io/p/py-basics/","title":"Python 기초"},{"content":"함수란? 그룹 지어진 작업\n긴 프로그램 작성 시 유용\n초기의 고급 언어(FORTRAN, COBOL, BASIC 등) → 함수 개념 미미\nC → 함수에 기반한 언어\n현대의 고급언어(C++, JAVA, C#, Python) → 객체 지향 언어\n함수 선언 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int avg(int a, int b); int main(void) { int a, b, c; a = 20; b = 12; c = avg(a, b); printf(\u0026#34;%d\\n\u0026#34;, c); } int avg(int a, int b) { int c; c = (a+b)/2; return c; } 함수를 호출하기 이전에 함수가 정의 또는 선언되어 있어야 함\n함수가 main보다 아래에 있으면 컴파일러 오류 발생\n하지만 함수가 아래에 있는 형태가 읽기에 편함\n해결 방법으로 함수의 머리 부분(함수 원형)만 미리 기술 함수가 선언되어 있으면 함수 정의는 프로그램의 어디에 위치해도 괜찮음\n매개변수: parameter, formal argument, 형식인자, 형식매개변수\n인자: argument, actual argument, 실인자, 실매개변수\nvoid 반환값 자료형 자리에 void를 적으면 반환값이 없다는 의미\n수를 끝낼 때 return 뒤에 반환값이 없어도 되고, 아예 return;이 없어도 됨\n매개변수 자리에 void를 적으면 매개변수가 없다는 의미\n다양한 함수 배열을 사용하는 함수 주의점 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int array_sum(int a[5]) { int i, sum; sum = 0; for(i=0;i\u0026lt;5;i++) { sum += a[i]; } a[2] = 8; return sum; } int main(void) { int b[5] = {10, 2, 3, 7, 9} printf(\u0026#34;%d\\n\u0026#34;, array_sum(b)); return 0; } array_sum 함수는 입력받은 배열 내의 수의 합을 계산하는 함수\n배열을 사용하는 함수는 값에 의한 호출 개념이 적용되지 않음\n실제로는 입력받은 b 배열의 이름만 잠시 a로 바꾼 것이기 때문에 함수 내부에서 a[2] = 8을 해버리면 b[2]의 값이 8로 바뀌게 됨\n값에 의한 호출은 포인터를 통해 단일하게 설명 가능\n이름만 재지정하는 것이기 때문에 매개변수에서 배열의 크기를 지정하는 것이 불필요 (int a[]만 써도 됨)\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int array_sum2(int a[][3], int n) { int i, j, sum; sum = 0; for(i=0;i\u0026lt;n;i++) { for(j=0;j\u0026lt;3;j++) { sum = sum + a[i][j]; } } return sum; } int main(void) { int b[2][3] = { {3,2,3}, {2,3,4} }; printf(\u0026#34;%d\\n\u0026#34;, array_sum2(b,2)); } 다차원 배열의 경우 첫 번째 크기만 생략 가능하고 나머지 크기는 지정 필요 (int a[][3])\n보통 첫 번째 크기는 따로 넘겨 받음 (위의 코드에서는 n=2)\n나머지 크기가 다를 경우 오류 발생\n재귀 함수 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int fact(int a) { int mul; if(a\u0026gt;=2) { mul = a*fact(a-1); } else { mul = 1; } return mul; } int main(void) { int res; res = fact(5); printf(\u0026#34;%d\u0026#34;, res); } 재귀 함수: 자기 자신을 다시 호출하는 함수\n코드는 새로 생성되는 것이 아니지만 변수는 함수는 호출할 때마다 새로 생성 (a, mul)\n함수가 반환되면 생성된 변수들도 같이 소멸\n무한히 호출할 수는 없기 때문에 마치는 조건 설정 필요\n난수 생성 함수 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int a, i; for (i=0;i\u0026lt;10;i++) { a = rand(); printf(\u0026#34;%d\\n\u0026#34;, a); } } 난수: 규칙이 없어서 다음에 나올 수를 예측할 수 없는 수 (로또 번호, 주사위 등)\nrand(): C 언어에서의 난수 생성 함수\n호출할 때마다 난수를 하나씩 반환\n난수의 범위: 0 ~ 32767 (컴퓨터에 따라 다를 수 있음)\n#include \u0026lt;stdlib.h\u0026gt;\nc\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(void) { int a, i; srand(time(NULL)); for (i=0;i\u0026lt;10;i++) { a = rand()%10+1; printf(\u0026#34;%d\\n\u0026#34;, a); } } srand(시드): rand의 시드를 설정하는 함수\n컴퓨터에서의 난수는 정해진 규칙에 따라 난수를 생성하기 때문에 위의 코드를 실행하면 같은 결과만 출력됨\n시드가 동일하면 여전히 같은 결과가 출력됨\nsrand(time(NULL))의 경우 실행 시간을 기준으로 실행할 때마다 시드를 바꿔줄 수 있음\nrand()%(b-a+1)+a: [a ~ b] 범위의 수만 출력\n","date":"2025-09-19T12:33:00+09:00","permalink":"https://kimcatchy.github.io/p/c-function/","title":"C 함수"},{"content":"자료구조 선형 자료구조\n항목들을 순서적으로 나열하여 저장\n리스트: 가장 자유로운 선형 자료구조\n스택, 큐, 덱: 항목의 접근이 맨 앞(전단)이나 맨 뒤(후단)로 제한\n비선형 자료구조\n항목들이 보다 복잡한 연결 관계를 가짐\n트리: 회사의 조직도나 컴퓨터의 폴더와 같은 계층 구조\n그래프: 가장 복잡한 연결 관계를 표현\n알고리즘 컴퓨터로 문제를 풀기 위한 단계적인 절차\n문제와 컴퓨터가 주어진 상태에서 문제를 해결하는 방법을 정밀하게 이해할 수 있는 언어로 기술한 것\n프로그램 = 자료구조 + 알고리즘\n조건 입력: 0개 이상의 입력이 존재하여야 함\n출력: 1개 이상의 출력이 존재해야 함\n명백성: 각 명령어의 의미는 모호하지 않고 명확해야 함\n유한성: 한정된 수의 단계 후에는 반드시 종료되어야 함\n유효성: 각 명령어들은 실행 가능한 연산이어야 함\n기술 방법 자연어 일반적인 자연어를 사용해서 설명하듯이 알고리즘을 표현\n일반 사람이 이해하기 쉽게 표현할 수 있으나, 최종적으로 코드로 변경하는 데는 한계가 있음\n어떤 알고리즘을 사용해야 할 지 아이디어가 떠오르지 않는 시점에서, 생각 범위를 넓히는 단계 정도에 사용\n흐름도 여러 종류의 상자와 상자를 이어주는 화살표를 이용해서 명령 순서를 표현\n간단한 알고리즘은 쉽게 표현할 수 있지만, 복잡한 알고리즘은 표현하기 어려운 경우가 많음\n유사코드 프로그래밍 언어보다는 좀 더 인간의 언어에 가까운 형태\n프로그램 코드와 일반 언어의 중간 형태\n프로그램 코드를 직접 코딩하는 것보다 알고리즘을 좀 더 명확하게 정립하는 데 도움이 되고, 코드에 설명을 달지 않아도 이해하는 데 무리 없음\n특정 언어 실제로 사용하는 프로그래밍 언어의 코드로 바로 작성 가능\n알고리즘의 가장 정확한 기술 가능\n구현 시의 사항들이 알고리즘의 핵심적인 내용들의 이해를 방해\n파이썬: C나 자바보다 훨씬 간결한 표현 가능\n추상 자료형 데이터와 그 데이터에 대한 추상적인 연산들로써 구성\n데이터나 연산이 무엇인가를 정의함\n데이터나 연산을 어떻게 구현할 것인지는 정의하지 않음\n자료구조는 추상 데이터 타입을 구체적(실제 프로그램)으로 구현한 것\n알고리즘의 성능 분석 실행 시간 측정\n두 개의 알고리즘의 실제 실행 시간을 측정\n실제로 구현하는 것이 필요\n동일한 하드웨어 사용\n복잡도 분석\n직접 구현하지 않고서도 수행 시간을 분석\n알고리즘이 수행하는 연산의 횟수를 측정하며 비교\n일반적으로 연산의 횟수는 n의 함수\n시간 복잡도 분석: 연산 수행 시간 분석\n공간 복잡도 분석: 수행 시 필요로 하는 메모리 공간 분석\n빅오 표기법 차수가 가장 큰 항이 절대적인 영향\n다른 항들은 상대적으로 무시\n빅오 표기법: 두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n \u0026gt; n₀에 대해 |f(n)| ≤ c|g(n)|을 만족하는 상수 C와 n₀가 존재하면 f(n) = O(g(n))\n최선 / 평균 / 최악 최선: 수행 시간이 가장 빠름 / 의미가 없는 경우가 많음\n평균: 수행 시간이 평균적인 경우 / 계산하기가 상당히 어려움\n최악: 수행 시간이 가장 늦은 경우 / 가장 널리 사용되며, 계산하기 쉽고 응용에 따라서 중요한 의미를 가짐\n순환 알고리즘 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법\n정의 자체가 순환적으로 되어 있는 경우에 적합\n팩토리얼 구하기, 피보나치 수열, 이항 계수, 하노이의 탑, 이진 탐색 등\n대부분의 순환은 반복으로 바꾸어 작성할 수 있음\n반복의 경우 for나 while문이 이용되고 수행 속도가 빠르지만 순환적인 문제에서는 프로그램 작성이 어려울 수 있음\n","date":"2025-09-19T12:17:00+09:00","permalink":"https://kimcatchy.github.io/p/data-structure-and-algorithm/","title":"자료구조 \u0026 알고리즘"},{"content":"배열이란? 여러 개의 변수를 동시에 만들어서 여러 개의 값을 처리하는데 유용\n반복문과 함께 여러 개의 값을 입력 받거나 출력하거나 처리할 때 유용\n첨자는 1부터가 아니라 0부터 → a[n]일 경우 0 ~ n-1\n정수형 뿐만 아니라 실수형, 문자형 모두 배열 사용 가능\n학생 5명의 점수 입력 받아 저장 후 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 int a[5]; int i; for (i=0; i\u0026lt;5; i++) { scanf(\u0026#34;%d\u0026#34;, %a[i]); } for (i=0; i\u0026lt;5; i++) { printf(\u0026#34;%d\u0026#34;, a[i]); } 배열의 초기화 처음 한 번은 한꺼번에 저장 가능 → 배열의 초기화\nint a[5] = {2, 5, 4, 3, 0};\n배열 선언 이후에는 할 수 없음\n초기화 값을 기술하지 않은 부분은 0으로 채움\nint a[5] = {5, 6}; → 5, 6, 0, 0, 0 모든 배열 요소들에 대해 초기화 값을 기술해주면 배열 크기 생략 가능\nint a[] = {3, 2, 7, 5} → 3, 2, 7, 5 2차원 배열 ","date":"2025-09-19T12:09:00+09:00","permalink":"https://kimcatchy.github.io/p/c-array/","title":"배열"},{"content":"자료형 저장하거나 계산하는 값의 종류\nC에서 다루는 자료형: 정수, 실수, 문자\n정수: int a;\n실수: float b;\n문자: char c;\nsizeof: 자료형의 크기를 알고 싶을 때 사용하는 연산자\n결과값은 바이트 단위의 크기\n동적할당 등에 유용하게 사용\n자료형의 크기는 컴퓨터나 운영체제에 따라 달라질 수 있음\n정수형 signed short int: 16비트 / -2^15~2^15-1 / short, short int, signed short\nunsigned short int: 16비트 / 0~2^16-1 / unsigned short\nsigned int: 32비트 / -2^31~2^31-1 / int, signed\nunsigned int: 32비트 / 0~2^32-1 / unsigned\nsigned long int: 32비트 / -2^31~2^31-1 / long, long int, signed long\nunsigned long int: 32비트 / 0~2^32-1 / unsigned long\n크기에 따라 int형이나 long int형으로 자동 설정\n수의 끝에 L이나 l을 추가하면 lont int형으로 설정\nU나 u를 추가하면 unsigned형으로 설정\n정수형 상수 진법 표기 8진법: 0으로 시작(0123 = 123(8))\n16진법: 0x or 0X로 시작(0x1A1B = 1A1B(16))\n정수형의 변환 명세 %d: printf, scanf: signed 10진수\n%u: printf, scanf: unsigned 10진수\n%o: printf, scanf: 8진수, 첫 자리 0 표기 안함\n%x: printf: 16진수, abcedf로 출력, 첫 자리 0X 표기 안함, scanf: 16진수, 첫 자리 0x나 0X 표기 안함\n%X: printf: 16진수, ABCDEF로 출력, 첫 자리 0X 표기 안함\n%i: printf: signed 10진수, scanf: 0이 처음에 있으면 8진수, 0x나 0X가 처음에 있으면 16진수로 해석, 어느 쪽도 아니면 10진수로 해석\nshort형 변수나 값에 대해 입출력을 하고 싶을 경우 변환 명세 글자 앞 h 추가\nlong형 변수나 값에 대해 입출력을 하고 싶을 경우 변환 명세 글자 앞 l 추가\n변환 지정자 [object Promise]- flag\n- `-` (왼쪽 맞춤) - `+` (양수에 대해서도 부호 출력) - `0` (남는 왼쪽 자리는 0으로 채움) - `#` (%o와 같이 사용되면 처음에 0을, %x(%X)와 같이 사용되면 처음에 0x(0X)를 출력) width\n정수\n출력할 자리의 폭 지정\n기본적으로 오른쪽 맞춤\nprecision\n정수\n출력할 최소의 자리수 지정\n남는 자리는 0으로 채움\n[object Promise]### 실수형\nfloat: 32비트\ndouble: 64비트\nlong double: 64, 96, 128비트\n12는 정수지만 12.0은 실수로 취급\ne나 E를 붙여 10의 몇 승이 곱해지는지 표기\n지수승 형태는 항상 실수형\n12.34e1 = 12.34 * 10^1 = 123.4\n기본적으로 double형\nfloat형을 원하면 f나 F를 뒤에 추가\nlong double형을 원하면 l이나 L을 뒤에 추가\n실수형의 변환 명세 float형 - printf\n%f: mmm.dddd의 형태\n%e, %E: 지수 표현 형태\n%g, %G: %f / %e / %E 중 적절한 형태\nfloat형 - scanf\n%f, %e, %E, %g, %G 모두 사용 가능하나 구별은 되지 않음 double형\nprintf의 경우 float형과 동일한 변환 명세\nscanf의 경우 %lf와 같이 앞에 l을 추가\n통일성을 위해 printf에서도 %lf등을 사용하도록 추가\nlong double형\n%Lf와 같이 앞에 L을 추가 변환 지정자 정수형과 같이 지정자들을 사용할 수 있음\nflag나 width는 동일하지만 precision에서 차이\n%f, %e, %E의 경우 소수점 이하 자리수, precision을 지정하지 않을 경우 소수점 이하 6자리\n%g, %G의 경우 유효 숫자의 최대 개수\n문자형 char: 8비트, -2^7~2^7-1\nsigned char: 8비트, 0~2^8-1\nunsigned char: 8비트, -2^72^7-1 또는 02^8-1\n문자는 정수로 바꾼 뒤 저장, 아스키 코드\n형변환 기본적으로 사칙연산은 같은 자료형끼리 해야 함, 결과도 같은 자료형이 됨\n서로 다른 자료형 간의 연산은 피연산자를 더 넓은 자료형으로 맞춰 결과도 더 넓은 자료형이 됨\nchar, short, signed, unsigned → int, unsigned int\n보통 컴퓨터가 가장 효율적으로 처리할 수 있는 자료형을 int형으로 정함 형 넓히기 5가지 규칙\n두 피연산자 중 하나가 long double이면 다른 하나도 long double로 변환\n위 경우가 아닐 때, 한 피연산자가 double이면 다른 하나도 double로 변환\n위 두 경우가 모두 아닐 때, 한 피연산자가 float이면 다른 하나도 float으로 변환\n위 경우들이 모두 아닐 때, char와 short는 int로 변환\n그리고 만일 한 연산자가 long이면 다른 하나도 long으로 변환\n","date":"2025-09-19T11:52:00+09:00","permalink":"https://kimcatchy.github.io/p/c-types-and-conversion/","title":"자료형과 형변환"},{"content":"While문을 통해 1 ~ 5 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i; i = 0; while (i \u0026lt; 5) { i += 1; printf(\u0026#34;%d\\n\u0026#34;, i); } } printf를 i의 증가 이전에 출력할 경우 0 ~ 4 출력 While문을 통해 1부터 n까지의 합계 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i, sum, en; i = 1; sum = 0; scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;en); while (i \u0026lt;= en) { sum += i; i += 1; } printf(\u0026#34;%d\\n\u0026#34;, sum); } 1부터 입력받은 숫자 en까지의 합계를 while문으로 계산한 뒤 출력 For문을 통해 1부터 n까지의 합계 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i, sum, en; i = 1; sum = 0; scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;en); for (i = 1; i \u0026lt;= en; i++) { sum += i; } printf(\u0026#34;%d\\n\u0026#34;, sum); } 소수 판별 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b, i; scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a); b = 0; for (i = 2; i \u0026lt; a; i++) { if (a % i == 0) { b = 1; break; } } if (b == 0) { printf(\u0026#34;%d is prime number\\n\u0026#34;, a); } else { printf(\u0026#34;%d is not prime number\\n\u0026#34;, a); } } a = 입력 받는 수\nb = 결과 출력 전 a의 소수 판별 여부 저장\ni를 2부터 1씩 증가시키며 a를 i로 나눠 약수 여부를 판단\n약수가 있을 경우 b를 1로 변경하고 for문을 중단(break)\nb의 값에 따라 결과 출력\n","date":"2025-09-19T11:48:00+09:00","permalink":"https://kimcatchy.github.io/p/c-loop/","title":"반복문"},{"content":"문제 공부하다가 아래의 두 코드를 실행했는데 결과가 동일하게 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i; i = 0; while (i \u0026lt; 5) { ++i; printf(\u0026#34;%d\\n\u0026#34;, i); } } // 출력 결과 1 2 3 4 5 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main(void) { int i; i = 0; while (i \u0026lt; 5) { i++; printf(\u0026#34;%d\\n\u0026#34;, i); } } // 출력 결과 1 2 3 4 5 전위연산자 \u0026amp; 후위연산자 전위연산자(++i): 연산자가 피연산자 앞에 위치하는 연산자\n먼저 값을 증가 시키거나 감소 시킨 후에 그 값을 사용\n예를 들어 ++i는 i의 값을 1 증가 시킨 후에 그 값을 반환\n후위연산자(i++): 연산자가 피연산자 뒤에 위치하는 연산자\n현재 값을 사용한 후에 값을 증가 시키거나 감소 시킴\n예를 들어 i++는 현재 i의 값을 사용한 후에 i의 값을 1 증가 시킴\n두 코드의 출력 결과가 같은 이유 두 코드 모두 i라는 변수를 0으로 초기화하고, i가 5보다 작을 동안 반복하며 i의 값을 출력하는 동작을 수행한다. 다만, i를 증가시키는 부분에서 전위연산자(++i)와 후위연산자(i++)를 사용하는 방식이 다르다.\n전위 연산자(++i)를 사용한 경우 printf 함수 호출 시점에 i의 값이 이미 1 증가된 상태이고, printf 함수는 증가된 i의 값을 출력\n출력되는 값은 1, 2, 3, 4, 5가 됨\n후위 연산자(i++)를 사용한 경우 printf 함수 호출 시점에 i의 값은 아직 증가되지 않은 상태, printf 함수는 증가되기 전의 i의 값을 출력\nprintf 함수 호출 후에 i의 값이 1 증가\n다음 반복에서 i의 값이 증가된 상태로 사용되므로, 출력되는 값은 1, 2, 3, 4, 5가 됨\n두 코드에서 printf 함수는 한 번의 반복마다 한 번씩 호출되며, 각 호출 시점에서 i의 값이 출력된다. 전위 연산자를 사용하든 후위 연산자를 사용하든, printf 함수가 호출될 때마다 i의 값은 그 이전 반복에서 1 증가된 상태이기 때문에 동일한 결과가 출력된다.\n즉, 이 두 코드에서는 printf 함수가 호출되는 시점이 증감 연산자가 적용되는 시점과 일치하기 때문에 전위 연산자와 후위 연산자의 차이가 출력 결과에 영향을 미치지 않는다.\n출력 결과에 영향을 주는 경우 c\u0026#43;\u0026#43; 1 2 3 int x = 10; int y = x++; // y는 10, x는 11 int z = ++x; // z는 12, x는 12 위 예시에서 볼 수 있듯이, 후위 연산자는 현재 값을 사용한 후에 증가시키고, 전위 연산자는 먼저 값을 증가시킨 후에 사용한다. 따라서 연산자의 위치에 따라 결과가 달라질 수 있다.\n","date":"2025-09-19T06:06:00+09:00","permalink":"https://kimcatchy.github.io/p/prefix-postfix/","title":"전위연산자 \u0026 후위연산자"},{"content":"음식 추천 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; int main(void) { char f; int\tm; printf(\u0026#34;Which food do u wanna eat? (w: western, k: korean)\\n\u0026#34;); scanf_s(\u0026#34; %c\u0026#34;, \u0026amp;f); printf(\u0026#34;How much do u have?\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;m); if (f == \u0026#39;w\u0026#39;) { if (m \u0026lt; 3000) { printf(\u0026#34;You should eat hamburger.\\n\u0026#34;); } else { printf(\u0026#34;You should eat pasta.\\n\u0026#34;); }; } else if (f == \u0026#39;k\u0026#39;) { if (m \u0026lt; 3000) { printf(\u0026#34;You should eat kimbap.\\n\u0026#34;); } else { printf(\u0026#34;You should eat samgyeopsal.\\n\u0026#34;); }; } else { printf(\u0026#34;Inappropriate food symbol!\\n\u0026#34;); }; } 양식/한식 선택 시 잘못된 문자 입력 시는 처리를 했는데, 가진 돈 입력 시 숫자 외의 값이 입력될 때는 아직 안 배워서 처리 못했음\nscanf_s 에서 문자 입력 시 %c 앞에 한 칸 띄우라는데, scanf로 입력 받을 시에 직접적으로 사용되지 않는 문자들(공백, 줄바꿈 등)은 버퍼에 그대로 남아있게 되는데, %c가 그것들을 사용하려고 해서 그렇다고 함, 공백을 넣어주면 공백을 버리고 입력을 받음\n입력한 두 수 중 큰 수 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b, c; scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;b); c = (a \u0026gt; b) ? a : b; printf(\u0026#34;Bigger numbur is: %d\\n\u0026#34;, c); } a와 b를 비교해서 a가 더 클 경우 c에 a의 값을 저장\n조건을 만족하지 못했을 경우 c에 b의 값이 저장됨\n","date":"2025-09-19T06:02:00+09:00","permalink":"https://kimcatchy.github.io/p/c-conditional-statements/","title":"조건문"},{"content":"두 입력값의 합 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a; int b; int c; printf(\u0026#34;input a \\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;input b \\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;b); c = a + b; printf(\u0026#34;result of c: \\n%d + %d = %d\u0026#34;, a, b, c); } #include \u0026lt;stdio.h\u0026gt;는 printf와 scanf를 사용하기 위한 헤더 파일을 불러오는 것\nVisual Studio에서 scanf에 문제가 있어 scanf_s 사용\n정수는 int, 실수는 float, 문자(문자열 X)는 char\nprintf 시 정수는 %d, 실수는 %f, 문자는 %c\n세 입력값의 합과 평균 출력 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(void) { float a, b, c; float sum, avg; printf(\u0026#34;input a \\n\u0026#34;); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;a); printf(\u0026#34;input b \\n\u0026#34;); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;b); printf(\u0026#34;input c \\n\u0026#34;); scanf_s(\u0026#34;%f\u0026#34;, \u0026amp;c); sum = a + b + c; avg = (a + b + c) / 3; printf(\u0026#34;sum of a, b, c: \\n%f + %f + %f = %f\\n\u0026#34;, a, b, c, sum); printf(\u0026#34;avg of a, b, c: \\n(%f + %f + %f) / 3 = %f\\n\u0026#34;, a, b, c, avg); } 나눗셈 후 몫과 나머지 c\u0026#43;\u0026#43; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; int q, r; scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;b); q = a / b; r = a % b; printf(\u0026#34;quotient: %d, remainder: %d\\n\u0026#34;, q, r); } ","date":"2025-09-19T05:57:00+09:00","permalink":"https://kimcatchy.github.io/p/c-var-io/","title":"변수와 입출력"},{"content":"기본 명령어 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 sudo 슈퍼유저 권한 sudo passwd 루트 계정 암호 설정 su 루트 계정으로 전환 adduser (이름) 사용자 추가 userdel (이름) 사용자 제거 su (이름) 사용자 전환 history 내가 입력했던 명령어 출력 clear 화면 비우기 chmod 권한 설정 chown (사용자:그룹) (파일) 소유자 설정 pwd 현재 위치의 전체 경로 표시 cd (경로) 해당 경로로 이동 ls 현재 디렉토리의 내용 표시 ls -R 하위 디렉토리의 파일까지 전부 표시 ls -a 숨김 파일 표시 ls -al 파일 세부 정보 표시 cat (파일명) 파일 생성 cp (파일) (경로) 파일 복사 mv (파일) (경로) 파일 이동 mkdir (경로) 디렉토리 생성 rmdir (경로) 디렉토리 제거 touch (파일) 빈 파일 생성 echo (내용) \u0026gt;\u0026gt; (파일) 파일에 내용 추가 locate (파일) 파일 검색 locate -i (A) (B) 내용에 A와 B가 포함된 파일 검색 find (A) A가 포함된 파일과 디렉토리 검색 grep (A) (파일) 파일 내에 A라는 내용이 있는지 검색 head -n (숫자) (파일) 파일 내용의 첫 n줄 출력 tail -n (숫자) (파일) 파일 내용의 끝 n줄 출력 diff (파일) (파일) 두 파일의 내용 비교 tar 압축 df 시스템 디스크 사용량 출력(KB) df -m 시스템 디스크 사용량 출력(MB) du -h 디스크 사용량 ping (주소) 서버 연결 상태 확인 wget (주소) 파일 다운로드 APT 관련 명령어 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 도움말 출력 apt --help // 패키지 목록 갱신 apt update // 패키지 최신 버전으로 업그레이드 apt upgrade // 패키지 목록 출력 apt list // 설치된 패키지 목록 출력 apt list --installed dpkg -l // 업그레이드 가능한 패키지 목록 출력 apt list --upgradable // 패키지 설치 (요구하는 패키지 함께 설치) apt install @@@ // 패키지 삭제, 설정 파일은 삭제 X apt remove @@@ // 필요 없는 패키지 삭제 apt autoremove // 설정 파일 포함 패키지 삭제 apt purge @@@ // 패키지 정보 출력 apt show @@@ // @@@와 관련된 패키지 검색 apt search @@@ 우분투 초기화 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 루트 사용자로 접속 exec sudo -i // 설정되지 않은 패키지 설정(?) dpkg --configure -a // 패키지 업데이트 apt-get update // 패키지 매니저 깨졌을 경우 복구 apt-get -f install // 시스템 업데이트 apt-get dist-upgrade // 우분투 재설치 apt-get install --reinstall ubuntu-desktop // 불필요한 패키지 제거 apt-get autoremove // 설치된 패키지 제거 apt-get clean // 재부팅 reboot 로그 파일 정리 bash 1 2 3 4 5 6 7 8 9 10 11 // 현재 + 하위 폴더 .gz 확장자 파일 검색 sudo find . -type f -name \u0026#34;*.gz\u0026#34; // 현재 + 하위 폴더 .gz 확장자 파일 삭제 sudo find . -type f -name \u0026#34;*.gz\u0026#34; -exec rm {} \\; // 현재 + 하위 폴더 60일 이상 된 .gz 확장자 파일 삭제 sudo find . -ctime +30 -type f -name \u0026#34;*.gz\u0026#34; -exec rm {} \\; // 현재 폴더 .gz 확장자 파일 삭제 sudo find . -maxdepth 1 -type f -name \u0026#34;*.gz\u0026#34; -exec rm {} \\; 메일 관련 명령어 bash 1 2 3 4 5 6 7 8 9 10 11 12 // 메일 확인 $ mail // 메일 읽기 \u0026gt; t메일번호 // 메일 삭제 \u0026gt; d메일번호 1번부터 8번을 삭제할 경우 d1-8 // 상태를 저장하고 종료 \u0026gt; q ","date":"2025-09-19T05:51:00+09:00","permalink":"https://kimcatchy.github.io/p/ubuntu-cheat-sheet/","title":"Ubuntu Cheat Sheet"},{"content":" python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import json import os def merge_json_files(folder_path): merged_data = [] for filename in os.listdir(folder_path): if filename.endswith(\u0026#34;.json\u0026#34;): file_path = os.path.join(folder_path, filename) with open(file_path, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: data = json.load(f) merged_data.extend(data) return merged_data def main(): base_folder = os.path.dirname(os.path.abspath(__file__)) merged_folder = os.path.join(base_folder, \u0026#34;0merged\u0026#34;) if not os.path.exists(merged_folder): os.makedirs(merged_folder) for item in os.listdir(base_folder): item_path = os.path.join(base_folder, item) if os.path.isdir(item_path) and item != \u0026#34;0merged\u0026#34;: merged_data = merge_json_files(item_path) output_file = os.path.join(merged_folder, f\u0026#34;{item}.json\u0026#34;) with open(output_file, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump(merged_data, f, ensure_ascii=False, indent=2) if __name__ == \u0026#34;__main__\u0026#34;: main() 0merged 폴더 생성 후 폴더 안에 병합된 json 작성\n이후 다시 사용할 수도 있으니 0merged 폴더는 병합 과정에서 제외\n","date":"2025-09-19T05:49:00+09:00","permalink":"https://kimcatchy.github.io/p/python-merge-json/","title":"Merge JSON in subDir"},{"content":" python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from PIL import Image import os import re def merge_images(folder_path): # 이미지 파일 불러오기 및 정렬 image_files = [f for f in os.listdir(folder_path) if f.endswith(\u0026#39;.png\u0026#39;)] image_data = [] for file in image_files: match = re.search(r\u0026#39;map_cell_x(-?\\d+)_y(-?\\d+)_bigtile\\.png\u0026#39;, file) if match: x, y = int(match.group(1)), int(match.group(2)) image_data.append((x, y, Image.open(os.path.join(folder_path, file)))) image_data.sort() # 좌표 기준 정렬 # 이미지 크기 계산 min_x = min(x for x, _, _ in image_data) max_x = max(x for x, _, _ in image_data) min_y = min(y for _, y, _ in image_data) max_y = max(y for _, y, _ in image_data) width = (max_x - min_x + 1) * image_data[0][2].width height = (max_y - min_y + 1) * image_data[0][2].height # 합쳐진 이미지 생성 merged_image = Image.new(\u0026#39;RGB\u0026#39;, (width, height)) for x, y, img in image_data: merged_image.paste(img, ((x - min_x) * img.width, (max_y - y) * img.height)) return merged_image # 현재 스크립트 파일 경로 가져오기 script_dir = os.path.dirname(os.path.abspath(__file__)) folder_path = script_dir # 폴더 경로를 스크립트 경로로 설정 merged_image = merge_images(folder_path) merged_image.save(\u0026#39;merged_image.png\u0026#39;) bash 1 python merge_images.py 좌표 기준은 x가 낮을수록 왼쪽, y가 낮을수록 아래 ","date":"2025-09-19T05:46:00+09:00","permalink":"https://kimcatchy.github.io/p/python-merge-image/","title":"Merge Image"},{"content":"SSH 포트 추가 오라클 클라우드 VCN 설정에서 변경할 포트 추가\n기존에 SSH 포트로 사용 중이던 22 포트는 바로 삭제해도 되지만, 문제가 생길 수 있으니 변경이 완료된 후에 삭제\nbash 1 2 3 4 # 포트 설정을 변경하기 전에 아래의 명령어로 현재 사용 중인 포트를 확인 cat /etc/ssh/sshd_config | egrep ^\\#?Port #Port 22 bash 1 2 # 확인 후 ssh 설정 파일 열기 sudo nano /etc/ssh/sshd_config bash 1 2 3 4 # 기본값이 22 포트이기 때문에 port 설정에 주석 처리가 되어있는데, 아래와 같이 입력 #Port 22 Port 22 Port 21212 bash 1 2 3 4 5 6 # 저장하고 다시 한번 사용 가능한 포트 확인 cat /etc/ssh/sshd_config | egrep ^\\#?Port #Port 22 Port 22 Port 21212 bash 1 2 3 4 5 6 7 8 # 제대로 추가됐다면 ssh 재시작 후 확인 sudo systemctl restart ssh sudo netstat -tnlp | grep sshd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 10785/sshd: /usr/sb tcp 0 0 0.0.0.0:21212 0.0.0.0:* LISTEN 10785/sshd: /usr/sb tcp6 0 0 :::22 :::* LISTEN 10785/sshd: /usr/sb tcp6 0 0 :::21212 :::* LISTEN 10785/sshd: /usr/sb 기존 포트 제거 포트를 추가한 방법과 반대로 진행\n완료 후 오라클 클라우드 VCN 설정에서도 포트 제거\nbash 1 sudo nano /etc/ssh/sshd_config bash 1 2 #Port 22 (주석 처리가 되지 않은 22 포트 제거) Port 21212 bash 1 2 3 4 5 # 저장 후 다시 포트 확인 cat /etc/ssh/sshd_config | egrep ^\\#?Port #Port 22 Port 21212 bash 1 2 3 4 5 6 # SSH 재시작 후 확인 sudo systemctl restart ssh sudo netstat -tnlp | grep sshd tcp 0 0 0.0.0.0:21212 0.0.0.0:* LISTEN 10785/sshd: /usr/sb tcp6 0 0 :::21212 :::* LISTEN 10785/sshd: /usr/sb ","date":"2025-09-19T05:05:00+09:00","permalink":"https://kimcatchy.github.io/p/oci-ssh-port/","title":"Oracle Cloud SSH 포트 변경"},{"content":"특정 경로(파일 유형) 제외 jpg나 png 같은 정적 파일까지 모두 로그에 남기다 보니 로그를 파악하기가 어려움\n조금 더 쉽게 로그를 확인하기 위해 특정 확장자의 파일들을 로그에서 제외\n제외할 파일 유형 설정 bash 1 2 3 4 5 # Log Exception - file map $request_uri $except_file { ~*\\.(ico|css|js|gif|jpg|jpeg|png|svg|woff|ttf|eot)$ 0; default 1; } nginx 설정 파일(default 등)의 하단에 아래의 내용을 추가\n로그에 기록할 확장자는 지우고 더 제외할 확장자가 있다면 추가로 입력\n제외할 로그 설정 bash 1 2 3 4 5 6 7 8 9 10 11 12 ... set $logging 1; if ( $except_file = 0 ) { set $logging 0; } access_log /var/log/nginx/도메인.access.log combined if=$logging; error_log /var/log/nginx/도메인.error.log; ... 기본으로 logging이라는 변수를 1로 설정해주고, except_file이 0일 경우에는 logging도 0으로 변경\nlogging이 0일 경우에는 access.log에 로그를 기록하지 않음\n파일 확장자로만 제외한다면 logging 부분을 없애고 if=$except_file;로 끝내도 되지만, 위와 같이 설정할 경우 다른 제외 조건들과 연계하기가 쉬움\n","date":"2025-09-19T03:16:00+09:00","permalink":"https://kimcatchy.github.io/p/nginx-exclude-path/","title":"Nginx 로그 특정 경로 제외"},{"content":"설정하는 이유 사이트 내에 존재하지 않는 경로에 접속할 경우 일반적으로 NodeBB같은 CMS에서는 페이지가 존재하지 않는다는 내용을 출력한다. 하지만 CMS 외부에 접속 가능한 경로를 지정해뒀을 때, 해당 경로에 없는 파일로의 접속을 시도하거나 오류가 나면 nginx에서 응답 코드를 출력한다.\n이 글은 21년도에 작성한 글을 티스토리에서 해당 블로그로 옮긴 것인데, 과거의 나는 이런 응답 코드도 서버 공격자에게는 정보가 될 수 있기 때문에 모두 404로 통합하는 것이 좋고, 기왕이면 응답 코드 페이지를 따로 설정해서 서버에 대한 정보(nginx)를 알려주지 않는 것이 좋다고 생각했다..\n근데 저 당시에는 내 사이트에 자꾸 이상한 로그를 남기는 사람들이 있어서 그랬고, 오히려 요새는 Cloudflare를 쓴 뒤로 딱히 신경 안 쓰고 있다 ㅋㅋ\n404.html 같은 에러 페이지를 만들어 Nginx에 매핑하면, 불필요한 서버 정보 노출을 줄이면서 일관된 화면 제공\nerror_page 지시어로 특정 상태 코드(e.g. 404, 500 등)에 원하는 페이지를 연결하고, internal로 직접 접근을 막으면 깔끔하고 안전\n설정 방법 커스텀 에러 페이지(e.g. 404.html)를 준비해 사이트 문서 루트(또는 지정 경로)에 배치\n서버 블록에 error_page를 추가해 코드→페이지 매핑을 설정하고, 해당 페이지 location에 internal 적용\n설정 테스트와 적용은 nginx -t, systemctl reload nginx 순으로 진행\n예시 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 # 상태 코드는 유지하고, 페이지는 커스텀으로 통일 server { # 루트/기본 설정 root /var/www/site; # 대표 에러 매핑(404 유지, 5xx 유지) error_page 404 /404.html; error_page 500 502 503 504 /50x.html; # 직접 접근 차단 location = /404.html { internal; } location = /50x.html { internal; } } bash 1 2 3 4 5 6 7 8 9 # 보안 노출 최소화를 위해 주요 에러를 404로 통일 server { root /var/www/site; # 400/401/403/404/5xx 모두 404 상태 + 같은 페이지로 통일 error_page 400 401 403 404 500 502 503 504 =404 /404.html; location = /404.html { internal; } } =는 상태코드를 바꿈 (e.g. =404)\n반면 단순 error_page 404 /404.html;은 404 상태를 유지 =만 쓰고 코드 미지정 시 백엔드/정적 처리 결과 코드가 그대로 나가 200으로 응답이 될 수 있으니, 통일하려면 =404 같이 명시\nerror_page는 내부 redirect이므로 메서드는 GET으로 변경되며, 에러 페이지는 internal로 외부 직접 접근을 막는 것이 좋다.\n주요 응답 코드 1xx (정보): 요청을 받았으며 프로세스를 계속한다.\n2xx (성공): 요청을 성공적으로 받았으며 인식했고 수용하였다.\n3xx (리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요하다.\n4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다.\n400(잘못된 요청): 서버가 요청의 구문을 인식하지 못했다.\n401(권한 없음): 이 요청은 인증이 필요하다. 서버는 로그인이 필요한 페이지에 대해 이 요청을 제공할 수 있다. 상태 코드 이름이 권한 없음(Unauthorized)으로 되어 있지만 실제 뜻은 인증 안됨(Unauthenticated)에 더 가깝다.\n403(Forbidden, 금지됨): 서버가 요청을 거부하고 있다. 예를 들자면, 사용자가 리소스에 대한 필요 권한을 갖고 있지 않다. (401은 인증 실패, 403은 인가 실패라고 볼 수 있음)\n404(Not Found, 찾을 수 없음): 서버가 요청한 페이지(Resource)를 찾을 수 없다. 예를 들어 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.\n5xx (서버 오류): 서버가 명백히 유효한 요청에 대해 충족을 실패했다.\n500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없다.\n502 (Bad Gateway, 불량 게이트웨이): 서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받았다.\n503(서비스를 사용할 수 없음): 서버가 오버로드되었거나 유지관리를 위해 다운되었기 때문에 현재 서버를 사용할 수 없다. 이는 대개 일시적인 상태이다.\n504(게이트웨이 시간초과): 서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 제때 요청을 받지 못했다.\n","date":"2025-09-19T02:55:00+09:00","permalink":"https://kimcatchy.github.io/p/nginx-custom-error-page/","title":"Nginx Custom Error Page"},{"content":"PM2란? Node.js 애플리케이션을 백그라운드에서 안정적으로 실행하는 프로세스 관리자\n재시작, 로그 관리, 무중단 재시작까지 지원\n전역 설치: npm install pm2@latest -g로 설치, 설치 후 pm2 -v로 버전 확인\n프로세스 관리 기본 실행: pm2 start app.js 관리 명령어 프로세스 목록: pm2 list\n프로세스 상태: pm2 status\n정지/재시작/삭제: pm2 stop \u0026lt;이름|id\u0026gt; / pm2 restart \u0026lt;이름|id\u0026gt; / pm2 delete \u0026lt;이름|id\u0026gt;\n자주 쓰는 옵션 프로세스 이름 지정: \u0026ndash;name \u0026lt;이름\u0026gt;\n파일 변경 시 자동 재시작: \u0026ndash;watch\n메모리 제한 초과 시 재시작: \u0026ndash;max-memory-restart \u0026lt;용량\u0026gt;\n로그 실시간 확인: pm2 logs, 출력 로그와 에러 로그 동시에 출력\npm2 log \u0026lt;이름|id\u0026gt;로 특정 프로세스 지정 로그 저장 위치: 기본 로그 파일은 $HOME/.pm2/logs에 저장, 각 앱별 out/err 로그 파일로 분리\n부팅 시 자동 시작 프로세스 목록 저장: pm2 save\n부팅 시 자동 복원 활성화: pm2 startup\n활성화 전 목록 저장 필수 수동 복원: pm2 resurrect\n재부팅 후 자동 복원이 안 될 경우 수동으로 복원 예시 pm2 start app.js --name myApp --watch\npm2 start \u0026quot;npm run dev\u0026quot; --name myApp\npm2 start npm --name \u0026quot;myApp\u0026quot; -- run dev\n","date":"2025-09-19T02:29:00+09:00","permalink":"https://kimcatchy.github.io/p/pm2/","title":"PM2"},{"content":"Cron이란? 반복 작업을 자동으로 실행해 주는 스케줄러\ne.g. 매일 새벽 백업, 10분마다 로그 정리, 서버 부팅 시 한 번 실행 등\n사용법 bash 1 2 #!/bin/bash echo \u0026#34;작동 테스트: $(date)\u0026#34; \u0026gt;\u0026gt; /home/ubuntu/cron_test.log 간단한 셸 스크립트를 작성하고, 예를 들어 /home/ubuntu/test.sh라면 아래의 명령어로 실행 권한 부여 bash 1 chmod +x /home/ubuntu/test.sh 실행 권한 부여 후에는 아래 명령어로 사용자 cron을 편집 bash 1 crontab -e 표현식 간단 요약: 분 시 일 월 요일 명령\ne.g. 30 4 1 * * /home/ubuntu/test.sh 요일의 경우 0(일) - 6(토)을 사용해도 되고, SUN - SAT도 가능\n일(일자)과 요일을 동시에 제한하면 OR로 동작\n특수 기호 별표(*) = 모든 값 매칭\n쉼표(,) = 여러 값 지정\n하이픈(-) = 범위\n슬래시(/) = 간격(*/10 → 10분 간격)\n특수 문자열 @reboot → 부팅(크론 데몬 시작) 시 1회 실행\n@hourly → 매시 정각(0분)\n@daily 또는 @midnight → 매일 00:00\n@weekly → 매주 일요일 00:00\n@monthly → 매월 1일 00:00\n@yearly 또는 @annually → 매년 1월 1일 00:00\n사용 예시 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 매분 실행 * * * * * /home/ubuntu/test.sh # 10분마다 */10 * * * * /home/ubuntu/test.sh # 매일 04:30 30 4 * * * /home/ubuntu/test.sh # 부팅 시 실행 @reboot /home/ubuntu/test.sh # 작업 별로 로그 남기기 */10 * * * * /home/ubuntu/test.sh \u0026gt;\u0026gt; /home/ubuntu/test.log 2\u0026gt;\u0026amp;1 자주 겪는 문제 해결 방법 실행이 안 될 때\n스크립트 권한 확인\n절대 경로로 수정\nPATH 지정\n명령 앞에 셸 지정 시도\n터미널에선 되는데 크론에서만 실패\n환경 변수 차이가 원인인 경우가 많음\n스크립트 맨 위에 필요한 변수(PATH 등)를 선언하거나 명령을 절대 경로로 변경\n메일 폭탄이 날아옴..\n최상단에 MAILTO=\u0026quot;\u0026quot; 작성 ","date":"2025-09-18T23:26:00+09:00","permalink":"https://kimcatchy.github.io/p/cron/","title":"Cron"},{"content":"array 관련 배열 내 다중 항목 검색 javascript 1 2 3 4 5 6 let names= [\u0026#34;Style\u0026#34;,\u0026#34;List\u0026#34;,\u0026#34;Raw\u0026#34;]; let results= names.filter(x =\u0026gt; x.toLowerCase().includes(\u0026#34;s\u0026#34;)); console.log(results); //[\u0026#34;Style\u0026#34;, \u0026#34;List\u0026#34;] names.forEach(x =\u0026gt; {if (x.toLowerCase().includes(\u0026#34;s\u0026#34;)) results.push(x)}); ","date":"2025-09-18T23:07:00+09:00","permalink":"https://kimcatchy.github.io/p/js-memo/","title":"자바스크립트 메모"},{"content":"노션과 블로그의 연동 엊그제 Hugo와 Stack theme을 통해 Github Pages로 블로그를 만들었다. 하지만 노션에 적은 걸 다시 vscode를 켜고 마크다운 파일로 작성하고.. 태그로 이미지를 첨부하고.. 커밋하고 푸시해서 적용을 하는 과정은 너무나도 귀찮다! 글을 쓰는 게 귀찮으면 글 쓰기가 싫어진다!\n그래서 nolog 를 통해 노션과 블로그를 연동하기로 했다. 기본적인 적용 방법은 해당 repo의 README에 있으니 생략하고, 몇 가지 수정한 것만 기록용으로 적어본다.\n노션 템플릿 수정 우선 템플릿을 현재 사용 중인 Hugo에 맞춰 속성을 추가/삭제했다.\n나중에 블로그에서 작성일을 출력할 때 시간도 표시하고 싶은데, 날짜 유형은 시간을 표시하지 않아서 date 속성의 유형을 기존의 날짜에서 작성 시점으로 변경\n문서를 저장할 때 content/post/{slug}/index.md로 저장해야 되기 때문에 slug 속성 추가\n선택 유형인 series 속성을 categories로 변경하고 유형을 다중 선택으로 변경\n페이지 URL 수정 typescript 1 2 3 4 // 페이지 URL을 생성합니다. const slugValue = page.properties[\u0026#39;slug\u0026#39;] as string; page.pageUrl = `${subDirPath}${slugValue}`; page.pageIdx = page.properties[\u0026#39;IDX\u0026#39;] as string; pageUrl에서 slug를 사용할 수 있게 수정했다. 기존에는 pageTitle을 통해 pageUrl이 결정됐는데, slug를 추가했으니 기존 코드는 지웠다. 여기서 알아서 subDir을 생성해주니까 SAVE_SUB_DIR 변수는 추가하면 안된다.\n데이터 추출 함수 수정 typescript 1 2 3 4 5 6 case \u0026#39;last_edited_time\u0026#39;: result[key] = this.formatDateForBlog(property.last_edited_time); break; case \u0026#39;created_time\u0026#39;: result[key] = this.formatDateForBlog(property.created_time); break; 기존에 생성되는 날짜 문자열의 포맷이 현재 사용 중인 포맷과 달라서 last_edited_time case를 수정해주고, 작성 시점을 frontmatter의 date로 사용할 거라 created_time도 추가했다.\ntypescript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private formatDateForBlog(dateString: string): string { try { // ISO 8601을 한국 표준시(KST)로 변환 const dt = new Date(dateString); const kstOffset = 9 * 60; // 한국은 UTC+9 const kstTime = new Date(dt.getTime() + kstOffset * 60000); // 2025-09-17 07:00:00+0900 형식으로 포맷팅 const year = kstTime.getUTCFullYear(); const month = String(kstTime.getUTCMonth() + 1).padStart(2, \u0026#39;0\u0026#39;); const day = String(kstTime.getUTCDate()).padStart(2, \u0026#39;0\u0026#39;); const hours = String(kstTime.getUTCHours()).padStart(2, \u0026#39;0\u0026#39;); const minutes = String(kstTime.getUTCMinutes()).padStart(2, \u0026#39;0\u0026#39;); const seconds = String(kstTime.getUTCSeconds()).padStart(2, \u0026#39;0\u0026#39;); return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}+0900`; } catch (error) { console.error(`[page.ts] Date formatting error: ${error}`); return dateString; // 실패 시 원본 반환 } } 파일의 아래 쪽에는 formatDateForBlog 함수를 작성했다. 기존의 2025-09-18T05:26:00.000Z 같은 ISOString 형식에서 2025-09-17 07:00:00+0900 형식으로 출력이 되게 변경했다.\ncategories 다중 선택 처리 typescript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private formatMarkdownMetadata(): string { const metadata = [\u0026#39;---\u0026#39;]; // 모든 properties 키에 대해 반복 for (const key in this.properties) { const value = this.properties[key]; // 값이 존재하고, 태그 혹은 카테고리 배열인 경우 특별 처리 if (value) { if (key === \u0026#39;tags\u0026#39; \u0026amp;\u0026amp; Array.isArray(value)) { metadata.push(`tags:\\n - ${value.join(\u0026#39;\\n - \u0026#39;)}`); } else if (key === \u0026#39;categories\u0026#39; \u0026amp;\u0026amp; Array.isArray(value)) { metadata.push(`categories:\\n - ${value.join(\u0026#39;\\n - \u0026#39;)}`); } else { // 기타 모든 속성에 대한 처리 metadata.push(`${key}: ${JSON.stringify(value)}`); } } } metadata.push(\u0026#39;---\u0026#39;, \u0026#39;\u0026#39;); return metadata.join(\u0026#39;\\n\u0026#39;); } categories도 tags처럼 frontmatter에서 배열을 리스트로 변경해서 출력하도록 수정했다.\n워크플로우 파일 수정 yaml 1 2 3 4 5 6 on: workflow_dispatch: push: pull_request: schedule: - cron: \u0026#39;0 0 * * *\u0026#39; 원래 매 정각 cronjob을 하게 되어있었는데, 굳이 여러 번 할 필요는 없을 것 같아서 자정마다 되게 변경했고, 보통은 그냥 수동으로 누른다..\nyaml 1 2 3 4 5 6 7 8 9 - name: Commit and Push Changes to Current Repository run: | git config user.name \u0026#39;${{ vars.GIT_USER_NAME }}\u0026#39; git config user.email \u0026#39;${{ vars.GIT_USER_EMAIL }}\u0026#39; git pull origin master --rebase || git pull origin master --allow-unrelated-histories git add . git commit -m \u0026#34;Update metadata\u0026#34; || echo \u0026#34;No changes to commit in current repo\u0026#34; git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ vars.GIT_USER_NAME }}/nolog.git git push origin HEAD:master git remote set-url origin 부분의 마지막에 notion-to-markdown.git으로 되어있어서 repo명이 다르다. nolog.git으로 바꿔주면 정상적으로 작동한다.\n결과 markdown 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- IDX: \u0026#34;2\u0026#34; slug: \u0026#34;image-test\u0026#34; tags: - Notion description: \u0026#34;이미지 테스트 용 포스트\u0026#34; categories: - Web update: \u0026#34;2025-09-18 17:35:00+0900\u0026#34; date: \u0026#34;2025-09-18 14:22:00+0900\u0026#34; 상태: \u0026#34;Ready\u0026#34; title: \u0026#34;이미지 테스트\u0026#34; --- ![](image1.png) ### 이미지 테스트 테스트테스트 frontmatter의 순서가 뒤죽박죽인 건 좀 불편하지만.. 어차피 이제 마크다운 파일을 직접 열진 않으니까 아무튼 좋았쓰!\n지금 글을 쓰면서 확인해보니 노션의 h2 태그가 마크다운 변환 과정에서 h3로 변환되는 거 같은데, 아마 노션에서는 h1 태그를 그냥 쓰는 경우가 많아서 SEO 및 접근성 때문에 이렇게 하신 것 같다. 나는 노션에서도 h1 태그를 쓰지 않기 때문에.. 수정을 할 지 노션에서는 h1을 쓸 지 고민을 좀 해봐야겠다..\n","date":"2025-09-18T20:58:00+09:00","permalink":"https://kimcatchy.github.io/p/notion-to-blog/","title":"Notion to Blog"},{"content":"Font \u0026amp; Line Break ~/layouts/partials/head/custom.html 추가하고 아래 내용 작성 html 1 2 3 \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; ~/assets/scss/custom.scss에 아래 내용 추가 scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 본문 폰트 body, .article-content { font-family: \u0026#39;Noto Sans KR\u0026#39;, sans-serif; } // 제목 폰트 body, .article-title { font-family: \u0026#39;Noto Sans KR\u0026#39;, sans-serif; } // 홈페이지 폰트 body, .article-page { font-family: \u0026#39;Noto Sans KR\u0026#39;, sans-serif; } /* 한글 줄바꿈 최적화 */ .article-content { word-break: keep-all; word-wrap: break-word; overflow-wrap: break-word; } /* 추가적으로 본문 전체에 적용 */ body { word-break: keep-all; word-wrap: break-word; } Link Embed Shortcode ~/layouts/shortcodes/linkembed.html 추가하고 아래 내용 작성 html 1 2 3 4 5 6 \u0026lt;!-- 기존 링크 텍스트 제거하고 전체 박스를 링크로 만들기 --\u0026gt; \u0026lt;a href=\u0026#34;{{ .Get \u0026#34;url\u0026#34; }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; class=\u0026#34;embed-link-box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;embed-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;embed-url\u0026#34;\u0026gt;{{ .Get \u0026#34;url\u0026#34; }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; ~/assets/scss/custom.scss에 아래 내용 추가 scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /* 링크 embed */ .embed-link-box { display: block; margin: 24px 0; padding: 16px 20px; border-radius: 12px; text-decoration: none; cursor: pointer; transition: all 0.3s ease; // 라이트 모드 (포스트 배경과 구분) [data-scheme=\u0026#34;light\u0026#34;] \u0026amp; { background-color: #f1f5f9; // 연한 회색 border: 1px solid #cbd5e1; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); \u0026amp;:hover { background-color: #e2e8f0; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); transform: translateY(-1px); } } // 다크 모드 (포스트 배경과 구분) [data-scheme=\u0026#34;dark\u0026#34;] \u0026amp; { background-color: #374151; // 진한 회색 border: 1px solid #4b5563; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); \u0026amp;:hover { background-color: #4b5563; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); transform: translateY(-1px); } } } .embed-content { display: flex; align-items: center; gap: 8px; \u0026amp;::before { content: \u0026#34;🔗\u0026#34;; font-size: 1.1em; opacity: 0.7; } } .embed-url { font-family: var(--code-font-family, monospace); font-size: 1.1rem; margin: 0; overflow-wrap: break-word; [data-scheme=\u0026#34;light\u0026#34;] \u0026amp; { color: #475569; } [data-scheme=\u0026#34;dark\u0026#34;] \u0026amp; { color: #d1d5db; } } 사용 시 아래와 같이 사용 markdown 1 {{\u0026lt; linkembed url=\u0026#34;https://kimcatchy.github.io\u0026#34; text=\u0026#34;nolog\u0026#34; \u0026gt;}} https://kimcatchy.github.io Collapsible Section Shortcode ~/layouts/shortcodes/details.html 생성 후 아래 내용 작성 html 1 2 3 4 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;{{ .Get \u0026#34;title\u0026#34; | default \u0026#34;더 보기\u0026#34; | markdownify }}\u0026lt;/summary\u0026gt; \u0026lt;div\u0026gt;{{ .Inner | markdownify }}\u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; 사용 시 아래와 같이 사용, title을 입력하지 않으면 default인 \u0026lsquo;더 보기\u0026rsquo;로 출력 markdown 1 2 3 {{\u0026lt; details title=\u0026#34;더 보기\u0026#34; \u0026gt;}} 쮜지직 {{\u0026lt; /details \u0026gt;}} 더 보기 쮜지직 Modified MacOS Style Code Blocks 적용한 기능 Custom Height for Code Blocks with Global Scrollbar Reduce Code Block Font Size MacOS-style Code Blocks Show Language on Code Block Header ~/static/img/code-header.svg 추가하고 아래 내용 작성 SVG 1 2 3 4 5 \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;450px\u0026#34; height=\u0026#34;130px\u0026#34;\u0026gt; \u0026lt;ellipse cx=\u0026#34;65\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(220,60,54)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(237,108,96)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;225\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(218,151,33)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(247,193,81)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;385\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(27,161,37)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(100,200,86)\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; ~/layouts/_default/_markup/render-codeblock.html 추가하고 아래 내용 작성 html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 {{ $lang := .Type | default \u0026#34;text\u0026#34; }} {{ $result := transform.HighlightCodeBlock . }} \u0026lt;div class=\u0026#34;code-block-wrapper\u0026#34;\u0026gt; \u0026lt;!-- 언어 라벨 표시 --\u0026gt; \u0026lt;div class=\u0026#34;code-block-header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;code-block-dots\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;dot red\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;dot yellow\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;dot green\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;code-block-language\u0026#34;\u0026gt;{{ $lang }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 실제 코드 블록 --\u0026gt; \u0026lt;div class=\u0026#34;code-block-content\u0026#34;\u0026gt; {{ $result.Wrapped }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ~/assets/scss/custom.scss에 아래 내용 추가 scss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 /* ============================= */ /* 코드 블록 설정 */ /* ============================= */ /* 최대 높이 변수 설정 */ $codeblock-max-height: 25em; /* 코드 블록 래퍼 */ .code-block-wrapper { background-color: var(--pre-background-color); border-radius: 10px; margin: 20px 0; box-shadow: var(--shadow-l1); overflow: hidden; width: 100%; position: relative; display: block; clear: both; } /* Mac 스타일 헤더 + 언어 라벨 */ .code-block-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; background-color: var(--card-background-selected); border-bottom: 2px solid var(--accent-color); min-height: 40px; border-radius: 10px 10px 0 0; } .code-block-dots { display: flex; gap: 8px; } .dot { width: 13px; height: 13px; border-radius: 50%; } .dot.red { background-color: #ff5f56; } .dot.yellow { background-color: #ffbd2e; } .dot.green { background-color: #27ca3f; } .code-block-language { color: var(--accent-color); font-family: var(--code-font-family); text-transform: uppercase; font-size: 1rem; font-weight: 700; letter-spacing: 0.8px; opacity: 0.9; } /* 코드 내용 영역 */ .code-block-content { position: relative; overflow: auto; max-height: $codeblock-max-height; -webkit-overflow-scrolling: touch; .highlight { margin: 0 !important; border-radius: 0 !important; box-shadow: none !important; background-color: transparent !important; padding: var(--card-padding) !important; } } /* 기존 .highlight:before 비활성화 */ .article-content .code-block-wrapper .highlight:before { display: none !important; } /* 기존 코드 블록 스타일 */ .highlight { max-height: $codeblock-max-height; overflow: auto; -webkit-overflow-scrolling: touch; } .highlight pre, .highlight code, .highlight .chroma { overflow: visible !important; } .lntable { display: inline-table; min-width: max-content; border-spacing: 0; } .lntd:last-child code, .highlight code { white-space: pre; } .lntd:first-child { user-select: none; } /* 기존 .highlight 스타일 */ .article-content .highlight { background-color: var(--pre-background-color); padding: var(--card-padding); position: relative; border-radius: 10px; max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; \u0026amp;:before { content: \u0026#34;\u0026#34;; display: block; background: url(/img/code-header.svg); height: 25px; width: 100%; background-size: 52px; background-repeat: no-repeat; margin-top: -10px; margin-bottom: 0; } } /* 좌측 폰트 설정 (ln) */ .chroma .lntd, .chroma .lntd pre, .chroma .ln { font-size: 14px; font-family: var(--code-font-family); } /* 우측 폰트 설정 (code) */ .chroma code, .chroma pre { font-size: 14px; font-family: var(--code-font-family); } Show Icon After External Links ~/layouts/_default/_markup/render-link.html 추가하고 아래 내용 작성 html 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;a class=\u0026#34;link\u0026#34; href=\u0026#34;{{ .Destination | safeURL }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34; {{ end }}{{ if strings.HasPrefix .Destination \u0026#34;http\u0026#34; }} target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; {{ end }}\u0026gt;{{ .Text | safeHTML }}\u0026lt;/a\u0026gt; {{ if strings.HasPrefix .Destination \u0026#34;http\u0026#34; }} \u0026lt;span style=\u0026#34;white-space: nowrap;\u0026#34;\u0026gt;\u0026lt;svg width=\u0026#34;.7em\u0026#34; height=\u0026#34;.7em\u0026#34; viewBox=\u0026#34;0 0 21 21\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z\u0026#34; fill=\u0026#34;currentColor\u0026#34; /\u0026gt; \u0026lt;path d=\u0026#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;/svg\u0026gt;\u0026lt;/span\u0026gt; {{ end }} Modified Stack Theme UI 적용한 기능 Back-to-Top Button Top Loading Progress Bar 참고한 블로그 글처럼 script.html 사용 시 기존 script.html이 override 돼서 오류 발생 ~/layouts/partials/footer/custom.html 추가하고 아래 내용 작성 html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 \u0026lt;!-- Back to Top Button --\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; id=\u0026#34;back-to-top\u0026#34; title=\u0026#34;Back to top\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- Back to Top Button Styles --\u0026gt; \u0026lt;style\u0026gt; #back-to-top { display: none; position: fixed; bottom: 5px; right: 15px; width: 40px; height: 40px; border-radius: 50%; background-color: var(--body-background); box-shadow: var(--shadow-l2); font-size: 20px; text-align: center; line-height: 38px; cursor: pointer; transition: transform 0.3s ease, background-color 0.3s ease; z-index: 999; } #back-to-top:before { content: \u0026#34;\u0026#34;; display: inline-block; position: relative; transform: rotate(135deg); height: 8px; width: 8px; border-width: 0 0 2px 2px; border-color: var(--accent-color); border-style: solid; } #back-to-top:hover { transform: scale(1.1); background-color: var(--accent-background); } /* 반응형 스타일 */ @media screen and (max-width: 768px) { #back-to-top { bottom: 5px; right: var(--container-padding); width: 30px; height: 30px; font-size: 16px; line-height: 32px; } } \u0026lt;/style\u0026gt; \u0026lt;!-- Back to Top + NProgress Script --\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // Back to Top 기능 const backToTopBtn = document.getElementById(\u0026#39;back-to-top\u0026#39;); function backToTop() { document.documentElement.scrollIntoView({ behavior: \u0026#39;smooth\u0026#39; }); } function updateBackToTopVisibility() { const scrollTop = document.documentElement.scrollTop || document.body.scrollTop; if (scrollTop \u0026gt; 200) { backToTopBtn.style.display = \u0026#39;inline\u0026#39;; } else { backToTopBtn.style.display = \u0026#39;none\u0026#39;; } } // 이벤트 리스너는 한 번만 등록 if (backToTopBtn) { backToTopBtn.addEventListener(\u0026#39;click\u0026#39;, function(e) { e.preventDefault(); backToTop(); }); window.addEventListener(\u0026#39;scroll\u0026#39;, updateBackToTopVisibility); updateBackToTopVisibility(); // 초기 상태 설정 } }); \u0026lt;!-- NProgress --\u0026gt; (function() { const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js\u0026#39;; script.integrity = \u0026#39;sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg\u0026#39;; script.crossOrigin = \u0026#39;anonymous\u0026#39;; script.onload = function() { const link = document.createElement(\u0026#39;link\u0026#39;); link.rel = \u0026#39;stylesheet\u0026#39;; link.href = \u0026#39;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css\u0026#39;; link.integrity = \u0026#39;sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE\u0026#39;; link.crossOrigin = \u0026#39;anonymous\u0026#39;; document.head.appendChild(link); if (typeof NProgress !== \u0026#39;undefined\u0026#39;) { let progressStarted = false; let progressCompleted = false; function startProgress() { if (!progressStarted) { NProgress.start(); progressStarted = true; progressCompleted = false; } } function completeProgress() { if (progressStarted \u0026amp;\u0026amp; !progressCompleted) { NProgress.done(); progressCompleted = true; progressStarted = false; } } // 즉시 시작 if (document.readyState === \u0026#39;loading\u0026#39;) { startProgress(); } // 다양한 완료 조건 체크 function checkAndComplete() { if (document.readyState === \u0026#39;complete\u0026#39;) { completeProgress(); return true; } return false; } // readyState 변경 감지 document.addEventListener(\u0026#39;readystatechange\u0026#39;, function() { if (document.readyState === \u0026#39;interactive\u0026#39;) { if (progressStarted) NProgress.inc(0.8); } else if (document.readyState === \u0026#39;complete\u0026#39;) { setTimeout(completeProgress, 100); // 약간의 지연 } }); // 추가 완료 조건들 window.addEventListener(\u0026#39;load\u0026#39;, function() { setTimeout(completeProgress, 200); }); // 강제 완료 타이머 (백업) setTimeout(function() { if (!progressCompleted) { console.log(\u0026#39;NProgress 강제 완료\u0026#39;); completeProgress(); } }, 10000); // 10초 후 강제 완료 // 페이지가 이미 로드된 경우 if (document.readyState === \u0026#39;complete\u0026#39;) { setTimeout(completeProgress, 100); } } }; document.head.appendChild(script); })(); \u0026lt;/script\u0026gt; References Hugo Stack Theme Customization Add collapsible section in hugo ","date":"2025-09-17T07:00:00+09:00","permalink":"https://kimcatchy.github.io/p/stack-custom/","title":"Hugo Stack Theme Customization"},{"content":"블로그를 이전하는 이유 돌고돌고돌고돌고 또 돌아서 결국 다시 Github Pages로 블로그를 생성했다. 어릴 때 웹 개발에 대해 아무것도 모를 때는 네이버 블로그와 티스토리를 썼는데, 웹 개발에 관심을 갖게 되면서 Github Pages로 블로그를 만들려 시도는.. 했었지만 실패했다..\n결국 티스토리를 꽤 오랜 시간 사용하다가 웹 개발에 관심을 갖게 되면서 node.js를 접하게 되고, Ghost로도 블로그를 운영했던 적이 있다. 하지만 당시에는 블로그를 생성은 했지만 딱히 작성할 컨텐츠가 없었고, 슬슬 도메인도 만료되면서 다시 또 티스토리로 글을 옮겼다.\n굳이 잘 사용하던 티스토리를 놔두고 Github Pages로 또또또 옮길 필요가 있을까 싶겠지만, 이 모든 게 다 Notion 때문이다. Notion도 익숙하지 않을 때는 \u0026lsquo;굳이 이걸 사용해야하나..\u0026rsquo; 싶었는데, 익숙해지니 문서를 작성하고 정리할 때는 Notion만 한 게 없더라! 결국 개인적으로 작성할 문서들은 Notion에, 일부 문서들은 티스토리 블로그에도 추가로 작성하면서 든 생각이 있는데..\n굳이 노션에 작성한 걸 다시 티스토리에 작성해야 되나?\n노션은 마크다운 문법을 사용하고 티스토리는 wysiwyg 에디터를 사용하는데, 이걸 또 바꿔서 작성하자니 귀찮은 점이 한둘이 아니다.\nnolog 그래서 알아보던 중 마침 나와 똑같은 생각을 한 사람이 있었는데.. 노션의 글을 GitHub 기반 블로그에 포스팅하는 nolog 라는 걸 발견했다. 해당 repo의 README를 보면 아래의 내용이 있다 ㅋㅋ\nhttps://github.com/Sharknia/nolog 노션으로 공부를 하는 개발자가 있습니다. 일을 하면서일수도 있고, 따로 짬을 내어 공부를 하면서일수도 있습니다. 그러다가 한 번 쯤은 생각하게 됩니다. 노션으로 한 공부나 작업 기록이 블로그에 자동으로 업로드된다면 좋을텐데!\n저 역시 마찬가지입니다. 저는 귀찮은 일이 너무 귀찮습니다. 공부나 블로그나 어차피 한 번에 할 수 있는거 아닌가? 공부만 하면 포스팅이 되면 안되나? 왜 똑같은 일을 두 번 세 번 해야 하는걸까?\n현재 운영 중인 서비스들의 docs 페이지 글을 작성하면서 마크다운 문서들을 편집할 일이 많이 생겼다. 마크다운 문법이야 디스코드를 오래 사용해와서 이미 익숙하지만, docs 페이지를 만들며 MKDocs를 처음 써봤는데 프론트매터를 작성하는게 왜 이렇게도 귀찮은 것인지!!!\n결국 Pages CMS를 통해 어느 정도는 자동화를 시켜뒀지만, 이것도 결국 문서를 작성할 때 웹 환경에서 작성해야 된다는 점은 변하지 않는다. 그래서 일단 nolog로 블로그에서 먼저 사용해보고.. 비슷한 방식으로 다른 것들도 notion으로 모두 해결하는 게 목표다..!\nHugo 뭐 깃허브에서 공식 지원하는 Jekyll도 있고 Gatsby, Hexo 등등 쓸 건 많았는데, 그냥 지금 적용한 Hugo 테마가 마음에 들어서 선택했다. node.js를 몇 년 째 잘 써먹고 있어서 Hexo를 써볼까 싶기도 했고, Gatsby가 React 기반이라 React를 연습할 겸 써볼까 싶기도 했는데, CSS 만지기도 귀찮고 그냥 눈에 보이는 게 Hugo였다..\n처음 써보는 거라 이것저것 귀찮은 게 많은 거 같은데 얼른 세팅 해두고 딸깍 한 번으로 글을 포스팅할 수 있는 날이 오길 바란다!!!\n","date":"2025-09-16T21:00:00+09:00","permalink":"https://kimcatchy.github.io/p/hugo-start/","title":"Hugo 블로그 시작"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks html 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block diff 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block html 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHugo Image Gallery markdown 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Photo by mymind and Luke Chesser on Unsplash Stack built-in math typesetting Stack has built-in support for math typesetting using KaTeX .\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nmarkdown 1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ markdown 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ markdown 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://kimcatchy.github.io/p/stack-cheat-sheet/","title":"Stack Cheat Sheet"},{"content":"For more details, check out the documentation .\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash ","date":"2023-08-25T00:00:00Z","permalink":"https://kimcatchy.github.io/p/shortcodes/","title":"Shortcodes"}]